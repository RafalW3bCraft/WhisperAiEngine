"""
G3r4ki Penetration Testing CLI Utilities

This module extends the G3r4ki CLI with penetration testing commands.
"""

import os
import sys
import logging
import argparse
import json
from typing import Any, Dict, List, Optional

# Setup logging
logger = logging.getLogger('g3r4ki.pentest.cli')

def add_cli_commands(cli_instance):
    """
    Add penetration testing commands to the G3r4ki CLI instance.
    
    Args:
        cli_instance: G3r4kiCLI instance
    """
    # Register the pentest command in the CLI
    cli_instance.do_pentest = _create_pentest_command(cli_instance)
    cli_instance.do_pentest.__doc__ = """Penetration testing operations
    Usage: pentest [shells|enum|privesc] [options]
           pentest shells [--list|--variants TYPE|--generate TYPE [VARIANT]|--all] [--ip IP] [--port PORT]
           pentest enum [--run] [--quick] [--verbose] [--output FILE] [--format FORMAT]
           pentest privesc [--list|--list-category CATEGORY|--info CATEGORY --technique-id ID|--report] [--output FILE] [--format FORMAT]
    """

def _create_pentest_command(cli_instance):
    """
    Create the pentest command function for the CLI.
    
    Args:
        cli_instance: G3r4kiCLI instance
        
    Returns:
        Command function
    """
    def do_pentest(self, arg):
        """Penetration testing operations"""
        # Parse arguments
        args = arg.split()
        
        if not args:
            print(self.do_pentest.__doc__)
            return
        
        command = args[0].lower()
        options = args[1:] if len(args) > 1 else []
        
        # Handle shell commands
        if command == "shells":
            _handle_shells_command(self, options)
        
        # Handle enumeration commands
        elif command == "enum":
            _handle_enum_command(self, options)
        
        # Handle privilege escalation commands
        elif command == "privesc":
            _handle_privesc_command(self, options)
        
        # Handle agent commands
        elif command == "agent":
            _handle_agent_command(self, options)
        
        # Unknown command
        else:
            print(f"Unknown pentest command: {command}")
            print(self.do_pentest.__doc__)
    
    return do_pentest

def _handle_shells_command(cli_instance, options):
    """
    Handle pentest shells command.
    
    Args:
        cli_instance: G3r4kiCLI instance
        options: Command options
    """
    from src.pentest.shells.reverse_shells import reverse_shells
    
    # Default values
    ip = reverse_shells.get_local_ip()
    port = 4444
    
    # Parse options
    i = 0
    action = "list"  # Default action
    shell_type = None
    shell_variant = None
    
    while i < len(options):
        option = options[i]
        
        if option == "--list":
            action = "list"
            i += 1
        
        elif option == "--variants" and i + 1 < len(options):
            action = "variants"
            shell_type = options[i + 1]
            i += 2
        
        elif option == "--generate" and i + 1 < len(options):
            action = "generate"
            shell_type = options[i + 1]
            
            # Check for variant
            if i + 2 < len(options) and not options[i + 2].startswith("--"):
                shell_variant = options[i + 2]
                i += 3
            else:
                i += 2
        
        elif option == "--all":
            action = "all"
            i += 1
        
        elif option == "--ip" and i + 1 < len(options):
            ip = options[i + 1]
            i += 2
        
        elif option == "--port" and i + 1 < len(options):
            try:
                port = int(options[i + 1])
            except ValueError:
                print(f"Invalid port number: {options[i + 1]}")
                return
            i += 2
        
        else:
            print(f"Unknown option: {option}")
            return
    
    # Execute requested action
    if action == "list":
        # List available shell types
        shell_types = reverse_shells.list_shell_types()
        
        print("Available Reverse Shell Types:")
        print("=" * 30)
        
        for stype in shell_types:
            print(f"  - {stype}")
        
        print("\nUse 'pentest shells --variants TYPE' to see variants for a specific type")
        print("Use 'pentest shells --generate TYPE VARIANT --ip IP --port PORT' to generate a shell")
    
    elif action == "variants":
        # Show variants for a specific shell type
        if not shell_type:
            print("Error: Shell type not specified")
            return
        
        variants = reverse_shells.list_shell_variants(shell_type)
        
        if not variants:
            print(f"Error: Unknown shell type '{shell_type}'")
            print("Use 'pentest shells --list' to see available types")
            return
        
        print(f"Variants for {shell_type} shells:")
        print("=" * 30)
        
        for variant in variants:
            print(f"  - {variant}")
        
        print("\nUse 'pentest shells --generate TYPE VARIANT --ip IP --port PORT' to generate a shell")
    
    elif action == "generate":
        # Generate a specific shell
        if not shell_type:
            print("Error: Shell type not specified")
            return
        
        # Get shell
        shell_command = None
        
        if shell_type == "bash":
            shell_command = reverse_shells.get_bash_shell(shell_variant, ip, port)
        
        elif shell_type == "python":
            shell_command = reverse_shells.get_python_shell(shell_variant, ip, port)
        
        elif shell_type == "perl":
            shell_command = reverse_shells.get_perl_shell(shell_variant, ip, port)
        
        elif shell_type == "ruby":
            shell_command = reverse_shells.get_ruby_shell(shell_variant, ip, port)
        
        elif shell_type == "php":
            shell_command = reverse_shells.get_php_shell(shell_variant, ip, port)
        
        elif shell_type == "powershell":
            shell_command = reverse_shells.get_powershell_shell(shell_variant, ip, port)
        
        elif shell_type == "java":
            shell_command = reverse_shells.get_java_shell(shell_variant, ip, port)
        
        elif shell_type == "golang":
            shell_command = reverse_shells.get_golang_shell(shell_variant, ip, port)
        
        elif shell_type == "netcat":
            shell_command = reverse_shells.get_netcat_shell(shell_variant, ip, port)
        
        elif shell_type == "socat":
            shell_command = reverse_shells.get_socat_shell(shell_variant, ip, port)
        
        else:
            print(f"Error: Unknown shell type '{shell_type}'")
            print("Use 'pentest shells --list' to see available types")
            return
        
        if shell_command:
            print("\nGenerated Reverse Shell:")
            print("=" * 30)
            print(shell_command)
            print("\nStart a listener with: nc -lvnp {port}")
            print(f"                      socat file:`tty`,raw,echo=0 tcp-listen:{port}")
        else:
            print(f"Error: Could not generate shell for type '{shell_type}' and variant '{shell_variant}'")
            print(f"Use 'pentest shells --variants {shell_type}' to see available variants")
    
    elif action == "all":
        # Generate all shell types
        print(f"Generating all shell types with IP {ip} and port {port}")
        print("=" * 50)
        
        shells = reverse_shells.get_all_shells(ip, port)
        
        for shell_type, variants in shells.items():
            print(f"\n{shell_type.upper()} Shells:")
            print("-" * 30)
            
            for variant, command in variants.items():
                print(f"\n[{variant}]")
                print(command)
        
        print("\nStart a listener with: nc -lvnp {port}")
        print(f"                      socat file:`tty`,raw,echo=0 tcp-listen:{port}")

def _handle_enum_command(cli_instance, options):
    """
    Handle pentest enum command.
    
    Args:
        cli_instance: G3r4kiCLI instance
        options: Command options
    """
    from src.pentest.enumeration.linux_enum import LinuxEnumerator
    
    # Default values
    run_scan = False
    quick_scan = False
    verbose = False
    output_file = None
    output_format = "text"
    
    # Parse options
    i = 0
    while i < len(options):
        option = options[i]
        
        if option == "--run":
            run_scan = True
            i += 1
        
        elif option == "--quick":
            quick_scan = True
            i += 1
        
        elif option == "--verbose":
            verbose = True
            i += 1
        
        elif option == "--output" and i + 1 < len(options):
            output_file = options[i + 1]
            i += 2
        
        elif option == "--format" and i + 1 < len(options):
            output_format = options[i + 1].lower()
            if output_format not in ["text", "json"]:
                print(f"Invalid output format: {output_format}")
                print("Supported formats: text, json")
                return
            i += 2
        
        else:
            print(f"Unknown option: {option}")
            return
    
    # Initialize enumerator
    enumerator = LinuxEnumerator(verbose=verbose)
    
    # Run enumeration if requested
    if run_scan:
        print(f"Running {'quick' if quick_scan else 'full'} enumeration scan...")
        
        if quick_scan:
            results = enumerator.run_quick_scan()
        else:
            results = enumerator.run_full_scan()
        
        print("Enumeration scan complete!")
        
        if output_format == "json":
            # Output JSON format
            if output_file:
                try:
                    with open(output_file, 'w') as f:
                        json.dump(results, f, indent=2)
                    print(f"Results saved to {output_file}")
                except Exception as e:
                    print(f"Error saving results: {str(e)}")
            else:
                print(json.dumps(results, indent=2))
        else:
            # Output text format
            report = enumerator.generate_report()
            
            if output_file:
                try:
                    with open(output_file, 'w') as f:
                        f.write(report)
                    print(f"Report saved to {output_file}")
                except Exception as e:
                    print(f"Error saving report: {str(e)}")
            else:
                print("\nEnumeration Report:")
                print("=" * 50)
                print(report)
    else:
        # Just show help
        print("Linux Enumeration Tool")
        print("=" * 30)
        print("This tool scans the local system for potential security issues")
        print("and privilege escalation vectors.")
        print("\nOptions:")
        print("  --run               Run enumeration scan")
        print("  --quick             Run quick scan (less thorough)")
        print("  --verbose           Enable verbose output")
        print("  --output FILE       Save results to file")
        print("  --format FORMAT     Output format (text, json)")
        print("\nExample:")
        print("  pentest enum --run --output enum_results.txt")
        print("  pentest enum --run --quick --format json --output enum_results.json")

def _handle_privesc_command(cli_instance, options):
    """
    Handle pentest privesc command.
    
    Args:
        cli_instance: G3r4kiCLI instance
        options: Command options
    """
    from src.pentest.privilege_escalation.linux_privesc import linux_privesc
    
    # Default values
    action = "list"
    category = None
    technique_id = None
    output_file = None
    output_format = "text"
    
    # Parse options
    i = 0
    while i < len(options):
        option = options[i]
        
        if option == "--list":
            action = "list"
            i += 1
        
        elif option == "--list-category" and i + 1 < len(options):
            action = "list_category"
            category = options[i + 1]
            i += 2
        
        elif option == "--info" and i + 1 < len(options):
            action = "info"
            category = options[i + 1]
            
            # Check for technique ID
            if i + 2 < len(options) and options[i + 2] == "--technique-id" and i + 3 < len(options):
                technique_id = options[i + 3]
                i += 4
            else:
                i += 2
        
        elif option == "--technique-id" and i + 1 < len(options):
            technique_id = options[i + 1]
            i += 2
        
        elif option == "--report":
            action = "report"
            i += 1
        
        elif option == "--output" and i + 1 < len(options):
            output_file = options[i + 1]
            i += 2
        
        elif option == "--format" and i + 1 < len(options):
            output_format = options[i + 1].lower()
            if output_format not in ["text", "json", "markdown"]:
                print(f"Invalid output format: {output_format}")
                print("Supported formats: text, json, markdown")
                return
            i += 2
        
        else:
            print(f"Unknown option: {option}")
            return
    
    # Execute requested action
    if action == "list":
        # List all privilege escalation categories
        categories = linux_privesc.list_categories()
        
        print("Linux Privilege Escalation Categories:")
        print("=" * 40)
        
        for cat in categories:
            print(f"  - {cat}")
        
        print("\nUse 'pentest privesc --list-category CATEGORY' to see techniques in a category")
    
    elif action == "list_category":
        # List techniques in a specific category
        if not category:
            print("Error: Category not specified")
            return
        
        techniques = linux_privesc.list_techniques(category)
        
        if not techniques:
            print(f"Error: Unknown category '{category}'")
            print("Use 'pentest privesc --list' to see available categories")
            return
        
        print(f"Privilege Escalation Techniques for {category}:")
        print("=" * 50)
        
        for technique_id, technique in techniques.items():
            print(f"\n[{technique_id}] {technique.get('name', 'Unnamed technique')}")
            print(f"  Description: {technique.get('description', 'No description')}")
        
        print("\nUse 'pentest privesc --info CATEGORY --technique-id ID' to see details for a specific technique")
    
    elif action == "info":
        # Show details for a specific technique
        if not category:
            print("Error: Category not specified")
            return
        
        if not technique_id:
            print("Error: Technique ID not specified")
            print("Use 'pentest privesc --info CATEGORY --technique-id ID'")
            return
        
        technique = linux_privesc.get_technique(category, technique_id)
        
        if not technique:
            print(f"Error: Unknown technique '{technique_id}' in category '{category}'")
            print(f"Use 'pentest privesc --list-category {category}' to see available techniques")
            return
        
        print(f"Privilege Escalation Technique: {technique.get('name', 'Unnamed technique')}")
        print("=" * 60)
        print(f"Category: {category}")
        print(f"ID: {technique_id}")
        print(f"Description: {technique.get('description', 'No description')}")
        print(f"Requirement: {technique.get('requirement', 'No requirements specified')}")
        print(f"Command:")
        print("-" * 40)
        print(technique.get('command', 'No command specified'))
        print("-" * 40)
        print(f"Reference: {technique.get('reference', 'No reference')}")
    
    elif action == "report":
        # Generate a comprehensive report of all techniques
        report = []
        all_techniques = {}
        
        # Get all categories and techniques
        categories = linux_privesc.list_categories()
        
        for category in categories:
            all_techniques[category] = linux_privesc.list_techniques(category)
        
        if output_format == "json":
            # JSON output
            if output_file:
                try:
                    with open(output_file, 'w') as f:
                        json.dump(all_techniques, f, indent=2)
                    print(f"Report saved to {output_file}")
                except Exception as e:
                    print(f"Error saving report: {str(e)}")
            else:
                print(json.dumps(all_techniques, indent=2))
        
        elif output_format == "markdown":
            # Markdown output
            report.append("# Linux Privilege Escalation Techniques")
            report.append("")
            
            for category in categories:
                report.append(f"## {category}")
                report.append("")
                
                techniques = all_techniques.get(category, {})
                
                for technique_id, technique in techniques.items():
                    report.append(f"### {technique.get('name', 'Unnamed technique')}")
                    report.append("")
                    report.append(f"**ID**: {technique_id}")
                    report.append("")
                    report.append(f"**Description**: {technique.get('description', 'No description')}")
                    report.append("")
                    report.append(f"**Requirement**: {technique.get('requirement', 'No requirements specified')}")
                    report.append("")
                    report.append("**Command**:")
                    report.append("```bash")
                    report.append(technique.get('command', 'No command specified'))
                    report.append("```")
                    report.append("")
                    report.append(f"**Reference**: {technique.get('reference', 'No reference')}")
                    report.append("")
            
            md_report = "\n".join(report)
            
            if output_file:
                try:
                    with open(output_file, 'w') as f:
                        f.write(md_report)
                    print(f"Report saved to {output_file}")
                except Exception as e:
                    print(f"Error saving report: {str(e)}")
            else:
                print(md_report)
        
        else:
            # Text output
            report.append("Linux Privilege Escalation Techniques")
            report.append("=" * 40)
            report.append("")
            
            for category in categories:
                report.append(f"{category}")
                report.append("-" * len(category))
                report.append("")
                
                techniques = all_techniques.get(category, {})
                
                for technique_id, technique in techniques.items():
                    report.append(f"[{technique_id}] {technique.get('name', 'Unnamed technique')}")
                    report.append(f"  Description: {technique.get('description', 'No description')}")
                    report.append(f"  Requirement: {technique.get('requirement', 'No requirements specified')}")
                    report.append(f"  Command: {technique.get('command', 'No command specified')}")
                    report.append(f"  Reference: {technique.get('reference', 'No reference')}")
                    report.append("")
            
            text_report = "\n".join(report)
            
            if output_file:
                try:
                    with open(output_file, 'w') as f:
                        f.write(text_report)
                    print(f"Report saved to {output_file}")
                except Exception as e:
                    print(f"Error saving report: {str(e)}")
            else:
                print(text_report)

def _handle_agent_command(cli_instance, options):
    """
    Handle pentest agent command.
    
    Args:
        cli_instance: G3r4kiCLI instance
        options: Command options
    """
    # Check if agent system is available
    if not cli_instance.agent_manager:
        print("Error: Agent system not available")
        return
    
    # Default values
    action = None
    target = None
    target_type = None
    agent_name = "PentestAgent"
    scope = "standard"
    
    # Parse options
    i = 0
    while i < len(options):
        option = options[i]
        
        if option == "create" and i + 1 < len(options):
            action = "create"
            target = options[i + 1]
            i += 2
        
        elif option == "run" and i + 1 < len(options):
            action = "run"
            agent_name = options[i + 1]
            i += 2
        
        elif option == "status":
            action = "status"
            i += 1
        
        elif option == "report" and i + 1 < len(options):
            action = "report"
            agent_name = options[i + 1]
            i += 2
        
        elif option == "--type" and i + 1 < len(options):
            target_type = options[i + 1]
            i += 2
        
        elif option == "--scope" and i + 1 < len(options):
            scope = options[i + 1].lower()
            if scope not in ["standard", "aggressive", "stealth"]:
                print(f"Invalid scope: {scope}")
                print("Supported scopes: standard, aggressive, stealth")
                return
            i += 2
        
        elif option == "--name" and i + 1 < len(options):
            agent_name = options[i + 1]
            i += 2
        
        else:
            print(f"Unknown option: {option}")
            return
    
    # Execute requested action
    if action == "create":
        # Create a new penetration testing agent
        if not target:
            print("Error: Target not specified")
            return
        
        print(f"Creating penetration testing agent for target: {target}")
        
        # Create agent
        try:
            agent = cli_instance.agent_manager.create_agent("pentest", agent_name)
            
            # Set target
            agent.set_target(target, target_type, scope)
            
            print(f"Agent created with ID: {agent.id}")
            print(f"Target: {target}")
            print(f"Target type: {target_type or 'auto-detected'}")
            print(f"Scope: {scope}")
            print("\nUse 'pentest agent run AGENT_ID' to run the agent")
        
        except Exception as e:
            print(f"Error creating agent: {str(e)}")
    
    elif action == "run":
        # Run a penetration testing agent
        if not agent_name:
            print("Error: Agent ID not specified")
            return
        
        print(f"Running penetration testing agent: {agent_name}")
        
        # Get agent
        agent = cli_instance.agent_manager.get_agent(agent_name)
        
        if not agent:
            print(f"Error: Agent '{agent_name}' not found")
            return
        
        if agent.type != "pentest":
            print(f"Error: Agent '{agent_name}' is not a penetration testing agent")
            return
        
        # Run agent
        try:
            print("Starting penetration test...")
            results = agent.execute()
            
            if results.get("success", False):
                print("\nPenetration test completed successfully!")
                print(f"Vulnerabilities found: {results.get('vulnerabilities_found', 0)}")
                print(f"Attack steps: {results.get('attack_steps', 0)}")
                
                print("\nUse 'pentest agent report AGENT_ID' to see the full report")
            else:
                print("\nPenetration test failed!")
                print(f"Error: {results.get('error', 'Unknown error')}")
        
        except Exception as e:
            print(f"Error running agent: {str(e)}")
    
    elif action == "status":
        # Show status of all penetration testing agents
        agents = cli_instance.agent_manager.list_agents()
        
        pentest_agents = [a for a in agents if a.type == "pentest"]
        
        if not pentest_agents:
            print("No penetration testing agents found")
            return
        
        print("Penetration Testing Agents:")
        print("=" * 30)
        
        for agent in pentest_agents:
            print(f"ID: {agent.id}")
            print(f"Name: {agent.name}")
            print(f"Target: {agent.target or 'Not set'}")
            print(f"Target type: {agent.target_type or 'Unknown'}")
            print(f"Scope: {agent.scope}")
            print("-" * 30)
    
    elif action == "report":
        # Show report for a specific agent
        if not agent_name:
            print("Error: Agent ID not specified")
            return
        
        # Get agent
        agent = cli_instance.agent_manager.get_agent(agent_name)
        
        if not agent:
            print(f"Error: Agent '{agent_name}' not found")
            return
        
        if agent.type != "pentest":
            print(f"Error: Agent '{agent_name}' is not a penetration testing agent")
            return
        
        # Generate report
        try:
            report = agent.generate_report()
            print(report)
        
        except Exception as e:
            print(f"Error generating report: {str(e)}")
    
    else:
        # Show help
        print("Penetration Testing Agent Operations")
        print("=" * 30)
        print("Options:")
        print("  create TARGET [--type TYPE] [--scope SCOPE] [--name NAME]")
        print("  run AGENT_ID")
        print("  status")
        print("  report AGENT_ID")
        print("\nExamples:")
        print("  pentest agent create 192.168.1.10 --type ip --scope aggressive")
        print("  pentest agent run PentestAgent")
        print("  pentest agent status")
        print("  pentest agent report PentestAgent")