"""
G3r4ki Linux Enumeration Module

This module provides Linux system enumeration capabilities for penetration testing.
It can identify potential privilege escalation vectors and system misconfigurations.
"""

import os
import re
import pwd
import grp
import stat
import socket
import platform
import subprocess
import logging
from typing import Dict, List, Any, Optional, Tuple, Union, Set
from datetime import datetime

# Setup logging
logger = logging.getLogger('g3r4ki.pentest.enumeration.linux')

class LinuxEnumerator:
    """
    Linux system enumeration for penetration testing and privilege escalation.
    
    This class provides methods to gather information about a Linux system,
    identify potential privilege escalation vectors, and discover misconfigurations.
    """
    
    def __init__(self, verbose: bool = False):
        """
        Initialize the Linux enumerator.
        
        Args:
            verbose: Whether to enable verbose logging
        """
        self.verbose = verbose
        self.results = {
            'system_info': {},
            'user_info': {},
            'network': {},
            'processes': [],
            'suid_binaries': [],
            'capabilities': [],
            'writable_paths': [],
            'cron_jobs': [],
            'sudo_info': {},
            'interesting_files': [],
            'container_detection': {},
            'exploitable_services': [],
            'kernel_vulns': []
        }
    
    def run_command(self, command: str) -> Tuple[str, Optional[str]]:
        """
        Run a shell command and return stdout and stderr.
        
        Args:
            command: Command to run
            
        Returns:
            Tuple of (stdout, stderr)
        """
        try:
            if self.verbose:
                logger.debug(f"Running command: {command}")
            
            process = subprocess.Popen(
                command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                shell=True,
                universal_newlines=True
            )
            stdout, stderr = process.communicate()
            
            if stderr and self.verbose:
                logger.debug(f"Command error: {stderr}")
            
            return stdout.strip(), stderr
        except Exception as e:
            logger.error(f"Error running command '{command}': {str(e)}")
            return "", str(e)
    
    def run_command_quietly(self, command: str) -> str:
        """
        Run a shell command quietly and return only stdout.
        
        Args:
            command: Command to run
            
        Returns:
            Command stdout or empty string on error
        """
        stdout, _ = self.run_command(command)
        return stdout
    
    def collect_system_info(self) -> Dict[str, str]:
        """
        Collect basic system information.
        
        Returns:
            Dictionary containing system information
        """
        info = {}
        
        # Hostname
        info['hostname'] = self.run_command_quietly("hostname")
        
        # Kernel version
        kernel = self.run_command_quietly("uname -a")
        info['kernel'] = kernel
        
        # OS release info
        if os.path.exists('/etc/os-release'):
            release = self.run_command_quietly("cat /etc/os-release")
            release_info = {}
            for line in release.splitlines():
                if '=' in line:
                    key, value = line.split('=', 1)
                    value = value.strip('"')
                    release_info[key] = value
            info['os_release'] = release_info
        
        # CPU info
        cpu_info = self.run_command_quietly("grep -m 1 'model name' /proc/cpuinfo")
        if cpu_info:
            info['cpu'] = cpu_info.split(':', 1)[1].strip()
        
        # Process count
        process_count = self.run_command_quietly("ps aux | wc -l")
        info['process_count'] = process_count
        
        # Uptime
        uptime = self.run_command_quietly("uptime")
        info['uptime'] = uptime
        
        # Last logins
        last_logins = self.run_command_quietly("last -a | head -3")
        info['last_logins'] = last_logins
        
        # Current user
        current_user = self.run_command_quietly("id")
        info['current_user'] = current_user
        
        self.results['system_info'] = info
        return info
    
    def collect_user_info(self) -> Dict[str, Any]:
        """
        Collect information about users on the system.
        
        Returns:
            Dictionary containing user information
        """
        info = {
            'current_user': {},
            'all_users': [],
            'sudo_users': [],
            'superusers': []
        }
        
        # Current user
        current_user = os.getenv('USER') or self.run_command_quietly("whoami")
        current_user_id = self.run_command_quietly(f"id {current_user}")
        info['current_user'] = {
            'name': current_user,
            'id_info': current_user_id
        }
        
        # Parse /etc/passwd for users
        try:
            users = []
            passwd_content = self.run_command_quietly("cat /etc/passwd")
            for line in passwd_content.splitlines():
                if line and ':' in line:
                    user_fields = line.split(':')
                    if len(user_fields) >= 7:
                        user = {
                            'username': user_fields[0],
                            'uid': user_fields[2],
                            'gid': user_fields[3],
                            'home': user_fields[5],
                            'shell': user_fields[6]
                        }
                        users.append(user)
            info['all_users'] = users
            
            # Identify superusers (UID 0)
            info['superusers'] = [user for user in users if user['uid'] == '0']
        except Exception as e:
            logger.error(f"Error parsing /etc/passwd: {str(e)}")
        
        # Check for users with sudo access
        sudo_users = []
        sudo_content = self.run_command_quietly("grep -v '#' /etc/sudoers 2>/dev/null | grep -E '^[a-zA-Z0-9_]+' 2>/dev/null")
        for line in sudo_content.splitlines():
            if line and not line.startswith('#'):
                parts = line.split()
                if parts:
                    sudo_users.append(parts[0])
        
        # Check sudo group members
        sudo_group = self.run_command_quietly("grep -Po '^sudo.+:\\K.*$' /etc/group 2>/dev/null")
        if sudo_group:
            for user in sudo_group.split(','):
                user = user.strip()
                if user and user not in sudo_users:
                    sudo_users.append(user)
        
        # Also check wheel group on some distros
        wheel_group = self.run_command_quietly("grep -Po '^wheel.+:\\K.*$' /etc/group 2>/dev/null")
        if wheel_group:
            for user in wheel_group.split(','):
                user = user.strip()
                if user and user not in sudo_users:
                    sudo_users.append(user)
        
        info['sudo_users'] = sudo_users
        
        self.results['user_info'] = info
        return info
    
    def find_suid_binaries(self) -> List[Dict[str, str]]:
        """
        Find SUID binaries which can potentially be used for privilege escalation.
        
        Returns:
            List of SUID binaries
        """
        suid_bins = []
        
        # Find SUID binaries
        cmd = "find / -type f -perm -4000 -ls 2>/dev/null"
        stdout, _ = self.run_command(cmd)
        
        for line in stdout.splitlines():
            parts = line.split()
            if len(parts) >= 11:
                # Parse the output format of ls -l
                permissions = parts[0]
                owner = parts[2]
                group = parts[3]
                size = parts[4]
                path = ' '.join(parts[10:])
                
                suid_bins.append({
                    'path': path,
                    'owner': owner,
                    'group': group,
                    'size': size,
                    'permissions': permissions
                })
        
        self.results['suid_binaries'] = suid_bins
        return suid_bins
    
    def find_capabilities(self) -> List[Dict[str, str]]:
        """
        Find binaries with special capabilities.
        
        Returns:
            List of binaries with capabilities
        """
        capabilities = []
        
        # Use getcap to find binaries with capabilities
        cmd = "getcap -r / 2>/dev/null"
        stdout, _ = self.run_command(cmd)
        
        for line in stdout.splitlines():
            if ' = ' in line:
                path, caps = line.split(' = ', 1)
                capabilities.append({
                    'path': path.strip(),
                    'capabilities': caps.strip()
                })
        
        self.results['capabilities'] = capabilities
        return capabilities
    
    def find_writable_paths(self) -> List[Dict[str, str]]:
        """
        Find world-writable paths that could be used for privilege escalation.
        
        Returns:
            List of writable paths
        """
        writable_paths = []
        
        # Find world-writable directories
        cmd = "find / -type d -perm -o+w -not -path '/proc/*' -not -path '/sys/*' 2>/dev/null"
        stdout, _ = self.run_command(cmd)
        
        for path in stdout.splitlines():
            writable_paths.append({
                'path': path,
                'type': 'directory'
            })
        
        # Find world-writable files
        cmd = "find / -type f -perm -o+w -not -path '/proc/*' -not -path '/sys/*' 2>/dev/null"
        stdout, _ = self.run_command(cmd)
        
        for path in stdout.splitlines():
            writable_paths.append({
                'path': path,
                'type': 'file'
            })
        
        self.results['writable_paths'] = writable_paths
        return writable_paths
    
    def find_cron_jobs(self) -> List[Dict[str, str]]:
        """
        Find cron jobs that could be exploited.
        
        Returns:
            List of cron jobs
        """
        cron_jobs = []
        
        # Check system-wide crontab
        cmd = "cat /etc/crontab 2>/dev/null"
        stdout, _ = self.run_command(cmd)
        
        if stdout:
            cron_jobs.append({
                'source': '/etc/crontab',
                'content': stdout
            })
        
        # Check /etc/cron.d directory
        cmd = "ls -la /etc/cron.d/ 2>/dev/null"
        stdout, _ = self.run_command(cmd)
        
        if stdout:
            for line in stdout.splitlines():
                if line.startswith('-'):
                    parts = line.split()
                    if len(parts) >= 9:
                        cron_file = parts[8]
                        cron_path = f"/etc/cron.d/{cron_file}"
                        content = self.run_command_quietly(f"cat {cron_path}")
                        
                        cron_jobs.append({
                            'source': cron_path,
                            'content': content
                        })
        
        # Check cron directories
        for cron_dir in ['/etc/cron.hourly', '/etc/cron.daily', '/etc/cron.weekly', '/etc/cron.monthly']:
            cmd = f"ls -la {cron_dir}/ 2>/dev/null"
            stdout, _ = self.run_command(cmd)
            
            if stdout:
                for line in stdout.splitlines():
                    if line.startswith('-'):
                        parts = line.split()
                        if len(parts) >= 9:
                            cron_file = parts[8]
                            cron_path = f"{cron_dir}/{cron_file}"
                            
                            cron_jobs.append({
                                'source': cron_path,
                                'type': 'script'
                            })
        
        # Check user crontabs
        user_crontabs = self.run_command_quietly("ls -la /var/spool/cron/crontabs/ 2>/dev/null")
        if user_crontabs:
            for line in user_crontabs.splitlines():
                if line.startswith('-'):
                    parts = line.split()
                    if len(parts) >= 9:
                        username = parts[8]
                        content = self.run_command_quietly(f"cat /var/spool/cron/crontabs/{username} 2>/dev/null")
                        
                        cron_jobs.append({
                            'source': f"/var/spool/cron/crontabs/{username}",
                            'user': username,
                            'content': content
                        })
        
        self.results['cron_jobs'] = cron_jobs
        return cron_jobs
    
    def check_sudo_config(self) -> Dict[str, Any]:
        """
        Check sudo configuration for the current user.
        
        Returns:
            Sudo configuration information
        """
        sudo_info = {
            'sudo_version': '',
            'sudo_privileges': [],
            'sudo_without_password': [],
            'exploitable_sudo': []
        }
        
        # Check sudo version
        sudo_version = self.run_command_quietly("sudo -V | head -n 1")
        sudo_info['sudo_version'] = sudo_version
        
        # Check sudo privileges
        sudo_l = self.run_command_quietly("sudo -l 2>/dev/null")
        sudo_info['sudo_privileges'] = sudo_l
        
        # Parse sudo -l output for interesting entries
        if sudo_l:
            for line in sudo_l.splitlines():
                line = line.strip()
                # Look for NOPASSWD entries
                if 'NOPASSWD' in line:
                    sudo_info['sudo_without_password'].append(line)
                
                # Check for common exploitable binaries
                exploitable_bins = ['vi', 'vim', 'nano', 'less', 'more', 'python', 'perl', 'ruby', 'irb', 'bash', 'sh', 'csh', 'ksh', 'zsh', 'cp', 'mv', 'find', 'nmap', 'awk', 'sed', 'ssh-keygen']
                
                for binary in exploitable_bins:
                    if f"/{binary}" in line or f"({binary})" in line or f" {binary} " in line:
                        if line not in sudo_info['exploitable_sudo']:
                            sudo_info['exploitable_sudo'].append(line)
        
        self.results['sudo_info'] = sudo_info
        return sudo_info
    
    def find_interesting_files(self) -> List[Dict[str, str]]:
        """
        Find potentially interesting files for privilege escalation.
        
        Returns:
            List of interesting files
        """
        interesting_files = []
        
        # Look for config files with credentials
        config_files = self.run_command_quietly("find /etc -name '*.conf' -o -name '*.cfg' -o -name '*.config' 2>/dev/null | grep -v '/proc/' | head -20")
        for file in config_files.splitlines():
            interesting_files.append({
                'path': file,
                'type': 'config'
            })
        
        # Look for SSH keys
        ssh_keys = self.run_command_quietly("find / -name 'id_rsa*' -o -name 'id_dsa*' -o -name 'id_ecdsa*' -o -name 'id_ed25519*' 2>/dev/null")
        for key in ssh_keys.splitlines():
            interesting_files.append({
                'path': key,
                'type': 'ssh_key'
            })
        
        # Look for history files
        history_files = self.run_command_quietly("find /home -name '.*history' 2>/dev/null")
        for file in history_files.splitlines():
            interesting_files.append({
                'path': file,
                'type': 'history'
            })
        
        # Check common password files
        passwd_files = [
            '/etc/passwd',
            '/etc/shadow',
            '/etc/master.passwd',
            '/etc/sudoers',
            '/etc/ssh/sshd_config'
        ]
        
        for file in passwd_files:
            if os.path.exists(file):
                perms = self.run_command_quietly(f"ls -la {file}")
                interesting_files.append({
                    'path': file,
                    'type': 'password_file',
                    'permissions': perms
                })
        
        # Check for backup files
        backup_files = self.run_command_quietly("find / -name '*.bak' -o -name '*.backup' -o -name '*.old' 2>/dev/null | head -20")
        for file in backup_files.splitlines():
            interesting_files.append({
                'path': file,
                'type': 'backup'
            })
        
        self.results['interesting_files'] = interesting_files
        return interesting_files
    
    def check_for_containers(self) -> Dict[str, bool]:
        """
        Check if running inside a container.
        
        Returns:
            Container detection results
        """
        container_info = {
            'is_container': False,
            'container_type': 'none',
            'is_docker': False,
            'is_lxc': False,
            'is_podman': False,
            'is_kubernetes': False
        }
        
        # Check for Docker
        if os.path.exists('/.dockerenv'):
            container_info['is_container'] = True
            container_info['is_docker'] = True
            container_info['container_type'] = 'docker'
        
        # Check cgroup
        cgroup = self.run_command_quietly("cat /proc/1/cgroup 2>/dev/null")
        if 'docker' in cgroup:
            container_info['is_container'] = True
            container_info['is_docker'] = True
            container_info['container_type'] = 'docker'
        elif 'lxc' in cgroup:
            container_info['is_container'] = True
            container_info['is_lxc'] = True
            container_info['container_type'] = 'lxc'
        
        # Check for Kubernetes
        if os.path.exists('/var/run/secrets/kubernetes.io'):
            container_info['is_container'] = True
            container_info['is_kubernetes'] = True
            container_info['container_type'] = 'kubernetes'
        
        # Check environment variables for k8s
        env_vars = os.environ
        for key in env_vars:
            if key.startswith('KUBERNETES_'):
                container_info['is_container'] = True
                container_info['is_kubernetes'] = True
                container_info['container_type'] = 'kubernetes'
                break
        
        self.results['container_detection'] = container_info
        return container_info
    
    def scan_network(self) -> Dict[str, Any]:
        """
        Scan network interfaces and connections.
        
        Returns:
            Network information
        """
        network_info = {
            'interfaces': [],
            'listening_ports': [],
            'active_connections': []
        }
        
        # Get network interfaces
        ifconfig = self.run_command_quietly("ifconfig 2>/dev/null || ip a 2>/dev/null")
        network_info['interfaces'] = ifconfig
        
        # Check listening ports
        listening = self.run_command_quietly("netstat -tuln 2>/dev/null || ss -tuln 2>/dev/null")
        if listening:
            for line in listening.splitlines():
                if 'LISTEN' in line:
                    network_info['listening_ports'].append(line)
        
        # Check active connections
        connections = self.run_command_quietly("netstat -tun 2>/dev/null | grep -v 'LISTEN' || ss -tun 2>/dev/null | grep -v 'LISTEN'")
        if connections:
            for line in connections.splitlines():
                if 'ESTABLISHED' in line:
                    network_info['active_connections'].append(line)
        
        # Check for localhost services
        localhost = self.run_command_quietly("netstat -tuln 2>/dev/null | grep '127.0.0.1' || ss -tuln 2>/dev/null | grep '127.0.0.1'")
        if localhost:
            network_info['localhost_services'] = localhost
        
        self.results['network'] = network_info
        return network_info
    
    def check_running_processes(self) -> List[Dict[str, str]]:
        """
        Check for interesting running processes.
        
        Returns:
            List of processes
        """
        processes = []
        
        # Get process list
        ps = self.run_command_quietly("ps aux")
        for line in ps.splitlines():
            parts = line.split()
            if len(parts) >= 11:
                user = parts[0]
                pid = parts[1]
                cpu = parts[2]
                mem = parts[3]
                command = ' '.join(parts[10:])
                
                processes.append({
                    'user': user,
                    'pid': pid,
                    'cpu': cpu,
                    'mem': mem,
                    'command': command
                })
        
        self.results['processes'] = processes
        return processes
    
    def find_kernel_vulnerabilities(self) -> List[Dict[str, str]]:
        """
        Check for known kernel vulnerabilities.
        
        Returns:
            List of potential kernel vulnerabilities
        """
        vulns = []
        
        # Get kernel version
        kernel = self.run_command_quietly("uname -r")
        
        # Very basic checks for common kernel exploits
        # This is not comprehensive and should be expanded with a proper vuln database
        
        # Check for Dirty COW (CVE-2016-5195)
        kernel_parts = kernel.split('.')
        if len(kernel_parts) >= 2:
            major = int(kernel_parts[0])
            minor = int(kernel_parts[1])
            
            if (major == 2 and minor <= 6) or (major == 3 and minor < 19) or (major == 4 and minor < 8):
                vulns.append({
                    'name': 'Dirty COW',
                    'cve': 'CVE-2016-5195',
                    'kernel': kernel,
                    'description': 'Race condition in the Linux kernel memory subsystem'
                })
        
        # Check for Meltdown/Spectre
        if os.path.exists('/proc/cpuinfo'):
            cpuinfo = self.run_command_quietly("cat /proc/cpuinfo")
            if 'Intel' in cpuinfo and (major < 4 or (major == 4 and minor < 15)):
                vulns.append({
                    'name': 'Meltdown/Spectre',
                    'cve': 'CVE-2017-5754, CVE-2017-5753, CVE-2017-5715',
                    'kernel': kernel,
                    'description': 'CPU vulnerabilities allowing memory access across boundaries'
                })
        
        self.results['kernel_vulns'] = vulns
        return vulns
    
    def run_full_scan(self) -> Dict[str, Any]:
        """
        Run a complete system enumeration.
        
        Returns:
            Complete scan results
        """
        logger.info("Starting full Linux enumeration scan")
        
        # Collect all information
        self.collect_system_info()
        self.collect_user_info()
        self.find_suid_binaries()
        self.find_capabilities()
        self.find_writable_paths()
        self.find_cron_jobs()
        self.check_sudo_config()
        self.find_interesting_files()
        self.check_for_containers()
        self.scan_network()
        self.check_running_processes()
        self.find_kernel_vulnerabilities()
        
        logger.info("Linux enumeration scan completed")
        return self.results
    
    def run_quick_scan(self) -> Dict[str, Any]:
        """
        Run a quick system enumeration focusing on the most likely privilege escalation vectors.
        
        Returns:
            Quick scan results
        """
        logger.info("Starting quick Linux enumeration scan")
        
        # Collect essential information
        self.collect_system_info()
        self.collect_user_info()
        self.find_suid_binaries()
        self.check_sudo_config()
        self.check_for_containers()
        
        logger.info("Quick Linux enumeration scan completed")
        return self.results
    
    def generate_report(self, format_type: str = 'text') -> str:
        """
        Generate a report of the enumeration results.
        
        Args:
            format_type: Report format (text, json, html)
            
        Returns:
            Formatted report
        """
        if format_type == 'json':
            import json
            return json.dumps(self.results, indent=2)
        
        # Text report (default)
        report = []
        report.append("=" * 50)
        report.append("G3r4ki Linux Enumeration Report")
        report.append(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append("=" * 50)
        
        # System info
        report.append("\n[+] System Information")
        report.append("-" * 50)
        sys_info = self.results.get('system_info', {})
        for key, value in sys_info.items():
            if isinstance(value, dict):
                report.append(f"  {key}:")
                for k, v in value.items():
                    report.append(f"    {k}: {v}")
            else:
                report.append(f"  {key}: {value}")
        
        # User info
        report.append("\n[+] User Information")
        report.append("-" * 50)
        user_info = self.results.get('user_info', {})
        
        # Current user
        current_user = user_info.get('current_user', {})
        report.append(f"  Current User: {current_user.get('name', 'Unknown')}")
        report.append(f"  ID Info: {current_user.get('id_info', 'Unknown')}")
        
        # Superusers
        superusers = user_info.get('superusers', [])
        if superusers:
            report.append("\n  Superusers (UID 0):")
            for user in superusers:
                report.append(f"    {user.get('username', 'Unknown')}")
        
        # Sudo users
        sudo_users = user_info.get('sudo_users', [])
        if sudo_users:
            report.append("\n  Sudo Users:")
            for user in sudo_users:
                report.append(f"    {user}")
        
        # SUID binaries
        suid_bins = self.results.get('suid_binaries', [])
        if suid_bins:
            report.append("\n[+] SUID Binaries")
            report.append("-" * 50)
            for binary in suid_bins:
                report.append(f"  {binary.get('path', 'Unknown')}")
                report.append(f"    Owner: {binary.get('owner', 'Unknown')}")
                report.append(f"    Group: {binary.get('group', 'Unknown')}")
                report.append(f"    Permissions: {binary.get('permissions', 'Unknown')}")
                report.append("")
        
        # Capabilities
        capabilities = self.results.get('capabilities', [])
        if capabilities:
            report.append("\n[+] Binaries with Capabilities")
            report.append("-" * 50)
            for cap in capabilities:
                report.append(f"  {cap.get('path', 'Unknown')}")
                report.append(f"    Capabilities: {cap.get('capabilities', 'Unknown')}")
                report.append("")
        
        # Sudo config
        sudo_info = self.results.get('sudo_info', {})
        if sudo_info:
            report.append("\n[+] Sudo Configuration")
            report.append("-" * 50)
            report.append(f"  Sudo Version: {sudo_info.get('sudo_version', 'Unknown')}")
            
            if sudo_info.get('exploitable_sudo', []):
                report.append("\n  Potentially Exploitable Sudo Entries:")
                for entry in sudo_info.get('exploitable_sudo', []):
                    report.append(f"    {entry}")
            
            if sudo_info.get('sudo_without_password', []):
                report.append("\n  Sudo Without Password:")
                for entry in sudo_info.get('sudo_without_password', []):
                    report.append(f"    {entry}")
        
        # Kernel vulnerabilities
        kernel_vulns = self.results.get('kernel_vulns', [])
        if kernel_vulns:
            report.append("\n[+] Potential Kernel Vulnerabilities")
            report.append("-" * 50)
            for vuln in kernel_vulns:
                report.append(f"  {vuln.get('name', 'Unknown')} ({vuln.get('cve', 'No CVE')})")
                report.append(f"    Kernel: {vuln.get('kernel', 'Unknown')}")
                report.append(f"    Description: {vuln.get('description', 'Unknown')}")
                report.append("")
        
        # Container detection
        container_info = self.results.get('container_detection', {})
        if container_info.get('is_container', False):
            report.append("\n[+] Container Detection")
            report.append("-" * 50)
            report.append(f"  Running in a container: {container_info.get('is_container', False)}")
            report.append(f"  Container type: {container_info.get('container_type', 'Unknown')}")
            
            for key, value in container_info.items():
                if key not in ['is_container', 'container_type'] and value:
                    report.append(f"  {key}: {value}")
        
        # Interesting files
        interesting_files = self.results.get('interesting_files', [])
        if interesting_files:
            report.append("\n[+] Interesting Files")
            report.append("-" * 50)
            for file in interesting_files:
                report.append(f"  {file.get('path', 'Unknown')}")
                report.append(f"    Type: {file.get('type', 'Unknown')}")
                if 'permissions' in file:
                    report.append(f"    Permissions: {file.get('permissions', 'Unknown')}")
                report.append("")
        
        return "\n".join(report)


# Make enumerator easily available
def run_linux_enumeration(verbose: bool = False, quick: bool = False) -> Dict[str, Any]:
    """
    Run Linux enumeration and return results.
    
    Args:
        verbose: Enable verbose output
        quick: Run a quick scan instead of full scan
        
    Returns:
        Enumeration results
    """
    enumerator = LinuxEnumerator(verbose=verbose)
    
    if quick:
        return enumerator.run_quick_scan()
    else:
        return enumerator.run_full_scan()

def generate_linux_report(results: Dict[str, Any], format_type: str = 'text') -> str:
    """
    Generate a report from enumeration results.
    
    Args:
        results: Enumeration results
        format_type: Report format (text, json, html)
        
    Returns:
        Formatted report
    """
    enumerator = LinuxEnumerator()
    enumerator.results = results
    return enumerator.generate_report(format_type)