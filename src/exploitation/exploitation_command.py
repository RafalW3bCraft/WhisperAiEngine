"""
G3r4ki Exploitation Command Module

This module provides CLI commands for exploitation operations.
"""

import argparse
import logging
import os
import sys
import json
from typing import Dict, List, Optional, Any

from src.exploitation.scanners.network_scanner import scan_target, get_available_scan_types, format_scan_results
from src.exploitation.scanners.ftp_scanner import check_ftp_service, try_anonymous_login, download_file as ftp_download
from src.exploitation.scanners.smb_scanner import check_smb_service, enum_smb_shares, list_share_contents
from src.exploitation.payloads.webshells import get_available_shells, generate_shell as generate_webshell
from src.exploitation.post.privilege_escalation import scan_for_privesc_vectors, exploit_suid_binary

# Setup logging
logger = logging.getLogger("g3r4ki.exploitation.command")

def handle_exploitation_command(args):
    """
    Handle exploitation command
    
    Args:
        args: Command line arguments
    """
    if args.exploit_command == "scan":
        handle_scan_command(args)
    elif args.exploit_command == "ftp":
        handle_ftp_command(args)
    elif args.exploit_command == "smb":
        handle_smb_command(args)
    elif args.exploit_command == "webshell":
        handle_webshell_command(args)
    elif args.exploit_command == "privesc":
        handle_privesc_command(args)
    else:
        print("Usage: g3r4ki.py exploit {scan,ftp,smb,webshell,privesc} [options]")
        print("\nRun with --help for more information on specific commands.")

def handle_scan_command(args):
    """
    Handle scan command
    
    Args:
        args: Command line arguments
    """
    try:
        logger.info(f"Scanning target: {args.target}")
        scan_results = scan_target(args.target, args.type, args.ports)
        
        # Print results
        formatted_results = format_scan_results(scan_results)
        print(formatted_results)
        
        # Save to file if requested
        if args.output:
            if args.output.endswith(".json"):
                with open(args.output, 'w') as f:
                    json.dump(scan_results, f, indent=2)
            else:
                with open(args.output, 'w') as f:
                    f.write(formatted_results)
            
            logger.info(f"Scan results saved to {args.output}")
        
    except Exception as e:
        logger.error(f"Error scanning target: {str(e)}")
        print(f"Error: {str(e)}")

def handle_ftp_command(args):
    """
    Handle FTP command
    
    Args:
        args: Command line arguments
    """
    if args.ftp_command == "check":
        try:
            logger.info(f"Checking FTP service on {args.target}:{args.port}")
            result = check_ftp_service(args.target, args.port)
            
            print(f"FTP Service Check: {args.target}:{args.port}")
            print(f"Status: {result['status']}")
            
            if result['status'] == 'online':
                print(f"Banner: {result['banner']}")
                if 'version' in result and result['version']:
                    print(f"Version: {result['version']}")
            
        except Exception as e:
            logger.error(f"Error checking FTP service: {str(e)}")
            print(f"Error: {str(e)}")
    
    elif args.ftp_command == "anon":
        try:
            logger.info(f"Trying anonymous FTP login on {args.target}:{args.port}")
            result = try_anonymous_login(args.target, args.port)
            
            print(f"Anonymous FTP Login: {args.target}:{args.port}")
            
            if 'error' in result:
                print(f"Error: {result['error']}")
            else:
                print(f"Anonymous Login Allowed: {result['anonymous_allowed']}")
                
                if result['anonymous_allowed']:
                    print("\nDirectories:")
                    for dir_info in result['directories']:
                        path = dir_info['path']
                        writeable = dir_info['writeable']
                        print(f"  {path} {'(writeable)' if writeable else ''}")
                        
                        if 'files' in dir_info and dir_info['files']:
                            print("  Files:")
                            for filename in dir_info['files']:
                                print(f"    {filename}")
            
        except Exception as e:
            logger.error(f"Error trying anonymous FTP login: {str(e)}")
            print(f"Error: {str(e)}")
    
    elif args.ftp_command == "get":
        try:
            logger.info(f"Downloading {args.remote_path} from {args.target}:{args.port} to {args.local_path}")
            result = ftp_download(args.target, args.port, args.remote_path, args.local_path, args.username, args.password)
            
            if result:
                print(f"File downloaded successfully to {args.local_path}")
            else:
                print("File download failed")
            
        except Exception as e:
            logger.error(f"Error downloading file: {str(e)}")
            print(f"Error: {str(e)}")
    
    else:
        print("Unknown FTP command. Use 'g3r4ki.py exploit ftp --help' for available commands.")

def handle_smb_command(args):
    """
    Handle SMB command
    
    Args:
        args: Command line arguments
    """
    if args.smb_command == "check":
        try:
            logger.info(f"Checking SMB service on {args.target}")
            result = check_smb_service(args.target)
            
            print(f"SMB Service Check: {args.target}")
            print(f"Status: {result['status']}")
            
            if result['status'] == 'online':
                ports = result['ports']
                print(f"NetBIOS (139/tcp): {'Open' if ports['netbios'] else 'Closed'}")
                print(f"SMB (445/tcp): {'Open' if ports['smb'] else 'Closed'}")
            
        except Exception as e:
            logger.error(f"Error checking SMB service: {str(e)}")
            print(f"Error: {str(e)}")
    
    elif args.smb_command == "enum":
        try:
            logger.info(f"Enumerating SMB shares on {args.target}")
            result = enum_smb_shares(args.target, args.username, args.password)
            
            print(f"SMB Share Enumeration: {args.target}")
            
            if 'error' in result:
                print(f"Error: {result['error']}")
            else:
                print(f"Authentication: {result['authentication']}")
                
                if 'shares' in result and result['shares']:
                    print("\nShares:")
                    for share in result['shares']:
                        readable = share.get('readable', False)
                        writeable = share.get('writeable', False)
                        access = []
                        if readable:
                            access.append("READ")
                        if writeable:
                            access.append("WRITE")
                        
                        access_str = f" ({', '.join(access)})" if access else ""
                        comment = f" - {share['comment']}" if share['comment'] else ""
                        
                        print(f"  {share['name']}{access_str}{comment}")
                else:
                    print("No shares found or access denied")
            
        except Exception as e:
            logger.error(f"Error enumerating SMB shares: {str(e)}")
            print(f"Error: {str(e)}")
    
    elif args.smb_command == "list":
        try:
            logger.info(f"Listing contents of {args.share} on {args.target}")
            result = list_share_contents(args.target, args.share, args.path, args.username, args.password)
            
            print(f"SMB Share Listing: {args.target}\\{args.share}\\{args.path}")
            
            if 'error' in result:
                print(f"Error: {result['error']}")
            else:
                if 'directories' in result and result['directories']:
                    print("\nDirectories:")
                    for directory in result['directories']:
                        print(f"  {directory['name']}  ({directory['path']})")
                
                if 'files' in result and result['files']:
                    print("\nFiles:")
                    for file in result['files']:
                        print(f"  {file['name']}  ({file['size']} bytes)")
                
                if not result['directories'] and not result['files']:
                    print("Directory is empty or access denied")
            
        except Exception as e:
            logger.error(f"Error listing SMB share contents: {str(e)}")
            print(f"Error: {str(e)}")
    
    else:
        print("Unknown SMB command. Use 'g3r4ki.py exploit smb --help' for available commands.")

def handle_webshell_command(args):
    """
    Handle webshell command
    
    Args:
        args: Command line arguments
    """
    if args.webshell_command == "list":
        try:
            available_shells = get_available_shells()
            
            print("Available Webshells:")
            
            for shell_type, variants in available_shells.items():
                print(f"\n{shell_type.upper()}:")
                for variant, description in variants.items():
                    print(f"  {variant}: {description}")
            
        except Exception as e:
            logger.error(f"Error listing webshells: {str(e)}")
            print(f"Error: {str(e)}")
    
    elif args.webshell_command == "generate":
        try:
            # Get available variants for the selected type
            available_shells = get_available_shells()
            
            if args.type not in available_shells:
                print(f"Unknown webshell type: {args.type}")
                print("Available types: " + ", ".join(available_shells.keys()))
                return
            
            if args.variant not in available_shells[args.type]:
                print(f"Unknown variant for {args.type}: {args.variant}")
                print(f"Available variants for {args.type}: " + ", ".join(available_shells[args.type].keys()))
                return
            
            logger.info(f"Generating {args.type} webshell, variant: {args.variant}")
            shell_code = generate_webshell(args.type, args.variant, args.password)
            
            # Save to file or print
            if args.output:
                with open(args.output, 'w') as f:
                    f.write(shell_code)
                
                print(f"Webshell saved to {args.output}")
            else:
                print("\nWebshell Code:")
                print("=" * 60)
                print(shell_code)
                print("=" * 60)
            
        except Exception as e:
            logger.error(f"Error generating webshell: {str(e)}")
            print(f"Error: {str(e)}")
    
    else:
        print("Unknown webshell command. Use 'g3r4ki.py exploit webshell --help' for available commands.")

def handle_privesc_command(args):
    """
    Handle privilege escalation command
    
    Args:
        args: Command line arguments
    """
    if args.privesc_command == "scan":
        try:
            logger.info("Scanning for privilege escalation vectors")
            result = scan_for_privesc_vectors()
            
            # Output as JSON if requested
            if args.output and args.output.endswith(".json"):
                with open(args.output, 'w') as f:
                    json.dump(result, f, indent=2)
                
                print(f"Scan results saved to {args.output}")
                return
            
            # Print results in human-readable format
            print("Privilege Escalation Vectors:")
            
            if 'suid_files' in result:
                exploitable_suid = [f for f in result['suid_files'] if f['is_exploitable']]
                
                if exploitable_suid:
                    print("\nExploitable SUID Binaries:")
                    for suid in exploitable_suid:
                        print(f"  {suid['file']} (owned by {suid['owner']})")
                        print(f"    {suid['exploit_info']}")
            
            if 'kernel_info' in result:
                kernel_info = result['kernel_info']
                print(f"\nKernel Version: {kernel_info['kernel_version']}")
                
                if 'vulnerable_to' in kernel_info and kernel_info['vulnerable_to']:
                    print("  Potentially Vulnerable to:")
                    for vuln in kernel_info['vulnerable_to']:
                        print(f"    {vuln['cve_id']} - {vuln['name']}")
                        print(f"      {vuln['description']}")
            
            if 'sudo_permissions' in result:
                sudo_info = result['sudo_permissions']
                if sudo_info['has_sudo']:
                    print("\nSudo Permissions:")
                    
                    if sudo_info['nopasswd_commands']:
                        print("  NOPASSWD Commands:")
                        for cmd in sudo_info['nopasswd_commands']:
                            print(f"    {cmd}")
                    
                    if sudo_info['sudo_commands']:
                        print("  Sudo Commands (require password):")
                        for cmd in sudo_info['sudo_commands']:
                            print(f"    {cmd}")
            
            if 'writable_paths' in result:
                writable = [p for p in result['writable_paths'] if p['status'] == 'writable']
                
                if writable:
                    print("\nWritable PATH Directories:")
                    for path in writable:
                        print(f"  {path['path']}")
            
            if 'cron_jobs' in result:
                writable_crons = [c for c in result['cron_jobs'] if c['writable']]
                
                if writable_crons:
                    print("\nWritable Cron Jobs:")
                    for cron in writable_crons:
                        print(f"  {cron['file']}")
            
            # Save to file if requested
            if args.output:
                with open(args.output, 'w') as f:
                    f.write("Privilege Escalation Vectors:\n")
                    
                    if 'suid_files' in result:
                        exploitable_suid = [f for f in result['suid_files'] if f['is_exploitable']]
                        
                        if exploitable_suid:
                            f.write("\nExploitable SUID Binaries:\n")
                            for suid in exploitable_suid:
                                f.write(f"  {suid['file']} (owned by {suid['owner']})\n")
                                f.write(f"    {suid['exploit_info']}\n")
                    
                    # Write other sections similarly...
                
                print(f"Scan results saved to {args.output}")
            
        except Exception as e:
            logger.error(f"Error scanning for privilege escalation vectors: {str(e)}")
            print(f"Error: {str(e)}")
    
    elif args.privesc_command == "exploit":
        try:
            if args.suid:
                logger.info(f"Generating exploit for SUID binary: {args.suid}")
                result = exploit_suid_binary(args.suid)
                
                print(f"SUID Binary Exploitation: {args.suid}")
                print(f"Exploitable: {result['exploitable']}")
                print(f"Instructions: {result['instructions']}")
                
                if result['commands']:
                    print("\nExploit Commands:")
                    for cmd in result['commands']:
                        print(f"  {cmd}")
            else:
                print("No exploitation method specified. Use --suid to specify a SUID binary to exploit.")
            
        except Exception as e:
            logger.error(f"Error generating exploit: {str(e)}")
            print(f"Error: {str(e)}")
    
    else:
        print("Unknown privilege escalation command. Use 'g3r4ki.py exploit privesc --help' for available commands.")