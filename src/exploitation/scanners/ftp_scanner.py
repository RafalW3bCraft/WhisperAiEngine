"""
G3r4ki FTP Scanner Module

This module provides FTP service scanning and exploitation capabilities
for tasks like anonymous login, directory traversal, and file upload/download.
"""

import ftplib
import socket
import logging
import os
import re
from typing import Dict, List, Optional, Union, Any, Tuple

# Setup logging
logger = logging.getLogger("g3r4ki.exploitation.scanners.ftp_scanner")

class FTPScanException(Exception):
    """Exception for FTP scanning errors"""
    pass

class FTPScanner:
    """
    FTP Scanner class
    
    This class provides methods to scan and exploit FTP services.
    """
    
    def __init__(self):
        """Initialize the FTP scanner"""
        self.last_scan_results = {}
        self.ftp_client = None
        self.current_connection = None
    
    def check_ftp_service(self, target: str, port: int = 21, timeout: int = 10) -> Dict[str, Any]:
        """
        Check if FTP service is running
        
        Args:
            target: Target hostname or IP
            port: FTP port
            timeout: Connection timeout in seconds
            
        Returns:
            Dictionary with service status and banner
        """
        try:
            with socket.create_connection((target, port), timeout=timeout) as sock:
                # Receive the welcome banner
                banner = sock.recv(1024).decode('utf-8', errors='ignore').strip()
                
                result = {
                    "status": "online",
                    "port": port,
                    "banner": banner,
                    "version": self._extract_version_from_banner(banner)
                }
                
                return result
        except (socket.timeout, ConnectionRefusedError) as e:
            logger.warning(f"Failed to connect to FTP service at {target}:{port}: {str(e)}")
            return {
                "status": "offline",
                "port": port,
                "error": str(e)
            }
    
    def _extract_version_from_banner(self, banner: str) -> Optional[str]:
        """
        Extract FTP server version from banner
        
        Args:
            banner: FTP server banner
            
        Returns:
            Server version if found, None otherwise
        """
        # Common FTP server patterns
        patterns = [
            r'vsFTPd (\d+\.\d+\.\d+)',  # vsFTPd 
            r'FTP Server \(Version (\d+\.\d+)',  # Generic FTP Server
            r'FileZilla Server (\d+\.\d+\.\d+)',  # FileZilla
            r'ProFTPD (\d+\.\d+\.\d+)',  # ProFTPD
            r'Microsoft FTP Service \(Version (\d+\.\d+))'  # Microsoft FTP
        ]
        
        for pattern in patterns:
            match = re.search(pattern, banner)
            if match:
                return match.group(1)
        
        return None
    
    def try_anonymous_login(self, target: str, port: int = 21, timeout: int = 10) -> Dict[str, Any]:
        """
        Try anonymous FTP login
        
        Args:
            target: Target hostname or IP
            port: FTP port
            timeout: Connection timeout in seconds
            
        Returns:
            Dictionary with login status and details
        """
        result = {
            "target": target,
            "port": port,
            "anonymous_allowed": False,
            "directories": [],
            "files": [],
            "banner": ""
        }
        
        try:
            ftp = ftplib.FTP(timeout=timeout)
            ftp.connect(target, port)
            
            # Save the banner
            result["banner"] = ftp.getwelcome()
            
            # Try anonymous login
            ftp.login('anonymous', 'anonymous@example.com')
            result["anonymous_allowed"] = True
            
            # Get current directory contents
            self._scan_ftp_directory(ftp, result)
            
            # Save connection for potential future use
            self.ftp_client = ftp
            self.current_connection = {
                "target": target,
                "port": port,
                "is_anonymous": True
            }
            
            return result
            
        except ftplib.error_perm as e:
            # Permission error (typically login failed)
            logger.info(f"Anonymous login failed: {str(e)}")
            result["error"] = str(e)
            return result
        except Exception as e:
            logger.error(f"Error during FTP scan: {str(e)}")
            result["error"] = str(e)
            return result
    
    def _scan_ftp_directory(self, ftp: ftplib.FTP, result: Dict[str, Any], max_depth: int = 2, current_depth: int = 0, current_path: str = "") -> None:
        """
        Scan FTP directory and recursively list contents
        
        Args:
            ftp: FTP client
            result: Result dictionary to update
            max_depth: Maximum recursion depth
            current_depth: Current recursion depth
            current_path: Current directory path
        """
        if current_depth > max_depth:
            return
        
        try:
            # List directory contents
            entries = []
            ftp.dir(entries.append)
            
            directories = []
            files = []
            
            # Parse the directory listing
            for entry in entries:
                parts = entry.split(maxsplit=8)
                if len(parts) >= 9:
                    permissions = parts[0]
                    size = parts[4]
                    filename = parts[8]
                    
                    if permissions.startswith('d'):
                        # This is a directory
                        directories.append({
                            "name": filename,
                            "permissions": permissions,
                            "path": f"{current_path}/{filename}".strip('/')
                        })
                    else:
                        # This is a file
                        files.append({
                            "name": filename,
                            "size": size,
                            "permissions": permissions,
                            "path": f"{current_path}/{filename}".strip('/')
                        })
            
            # Update the result with current directory contents
            dir_info = {
                "path": current_path if current_path else "/",
                "directories": [d["name"] for d in directories],
                "files": [f["name"] for f in files],
                "writeable": self._check_directory_writeable(ftp, current_path)
            }
            
            result["directories"].append(dir_info)
            
            # Scan subdirectories recursively
            if current_depth < max_depth:
                original_dir = ftp.pwd()
                
                for directory in directories:
                    dir_name = directory["name"]
                    if dir_name in [".", ".."]:
                        continue
                    
                    try:
                        # Change to subdirectory
                        ftp.cwd(dir_name)
                        
                        # Recursively scan the subdirectory
                        subdir_path = f"{current_path}/{dir_name}".strip('/')
                        self._scan_ftp_directory(
                            ftp, 
                            result, 
                            max_depth, 
                            current_depth + 1, 
                            subdir_path
                        )
                        
                        # Return to original directory
                        ftp.cwd(original_dir)
                    except ftplib.error_perm:
                        # Cannot access this directory
                        pass
                    
        except ftplib.error_perm as e:
            logger.warning(f"Permission error listing directory: {str(e)}")
    
    def _check_directory_writeable(self, ftp: ftplib.FTP, path: str = "") -> bool:
        """
        Check if directory is writeable by attempting to create a temporary file
        
        Args:
            ftp: FTP client
            path: Directory path
            
        Returns:
            True if writeable, False otherwise
        """
        original_dir = ftp.pwd()
        test_filename = ".g3r4ki_write_test"
        
        try:
            # Change to target directory if path is provided
            if path and path != "/":
                ftp.cwd(path)
            
            # Try to create a test file
            test_data = b"G3r4ki write test"
            ftp.storbinary(f"STOR {test_filename}", io.BytesIO(test_data))
            
            # If successful, delete the test file
            ftp.delete(test_filename)
            
            # Return to original directory
            if path and path != "/":
                ftp.cwd(original_dir)
                
            return True
            
        except ftplib.error_perm:
            # Permission error - directory is not writeable
            # Return to original directory
            if path and path != "/":
                try:
                    ftp.cwd(original_dir)
                except:
                    pass
            return False
        except Exception as e:
            logger.error(f"Error checking directory write permission: {str(e)}")
            # Try to return to original directory
            if path and path != "/":
                try:
                    ftp.cwd(original_dir)
                except:
                    pass
            return False
    
    def download_file(self, target: str, port: int, remote_path: str, local_path: str, 
                     username: str = "anonymous", password: str = "anonymous@example.com") -> bool:
        """
        Download a file from FTP server
        
        Args:
            target: Target hostname or IP
            port: FTP port
            remote_path: Remote file path
            local_path: Local file path
            username: FTP username
            password: FTP password
            
        Returns:
            True if download successful, False otherwise
            
        Raises:
            FTPScanException: If download fails
        """
        try:
            # Create a new connection or use existing one
            ftp = None
            
            if (self.ftp_client is not None and 
                self.current_connection["target"] == target and 
                self.current_connection["port"] == port and
                (self.current_connection["is_anonymous"] or
                 (self.current_connection.get("username") == username and 
                  self.current_connection.get("password") == password))):
                # Use existing connection
                ftp = self.ftp_client
            else:
                # Create new connection
                ftp = ftplib.FTP(timeout=10)
                ftp.connect(target, port)
                ftp.login(username, password)
                
                # Save connection
                self.ftp_client = ftp
                self.current_connection = {
                    "target": target,
                    "port": port,
                    "is_anonymous": (username == "anonymous"),
                    "username": username,
                    "password": password
                }
            
            # Create local directory if it doesn't exist
            local_dir = os.path.dirname(local_path)
            if local_dir and not os.path.exists(local_dir):
                os.makedirs(local_dir, exist_ok=True)
            
            # Download the file
            with open(local_path, 'wb') as local_file:
                ftp.retrbinary(f"RETR {remote_path}", local_file.write)
            
            logger.info(f"Downloaded {remote_path} to {local_path}")
            return True
            
        except Exception as e:
            logger.error(f"Error downloading file: {str(e)}")
            raise FTPScanException(f"Failed to download {remote_path}: {str(e)}")
    
    def upload_file(self, target: str, port: int, local_path: str, remote_path: str,
                   username: str = "anonymous", password: str = "anonymous@example.com") -> bool:
        """
        Upload a file to FTP server
        
        Args:
            target: Target hostname or IP
            port: FTP port
            local_path: Local file path
            remote_path: Remote file path
            username: FTP username
            password: FTP password
            
        Returns:
            True if upload successful, False otherwise
            
        Raises:
            FTPScanException: If upload fails
        """
        try:
            # Create a new connection or use existing one
            ftp = None
            
            if (self.ftp_client is not None and 
                self.current_connection["target"] == target and 
                self.current_connection["port"] == port and
                (self.current_connection["is_anonymous"] or
                 (self.current_connection.get("username") == username and 
                  self.current_connection.get("password") == password))):
                # Use existing connection
                ftp = self.ftp_client
            else:
                # Create new connection
                ftp = ftplib.FTP(timeout=10)
                ftp.connect(target, port)
                ftp.login(username, password)
                
                # Save connection
                self.ftp_client = ftp
                self.current_connection = {
                    "target": target,
                    "port": port,
                    "is_anonymous": (username == "anonymous"),
                    "username": username,
                    "password": password
                }
            
            # Check if local file exists
            if not os.path.exists(local_path) or not os.path.isfile(local_path):
                raise FTPScanException(f"Local file {local_path} not found")
            
            # Upload the file
            with open(local_path, 'rb') as local_file:
                ftp.storbinary(f"STOR {remote_path}", local_file)
            
            logger.info(f"Uploaded {local_path} to {remote_path}")
            return True
            
        except Exception as e:
            logger.error(f"Error uploading file: {str(e)}")
            raise FTPScanException(f"Failed to upload {local_path}: {str(e)}")
    
    def brute_force_login(self, target: str, port: int = 21, usernames: List[str] = None, 
                          passwords: List[str] = None, timeout: int = 5) -> Dict[str, Any]:
        """
        Brute force FTP login
        
        Args:
            target: Target hostname or IP
            port: FTP port
            usernames: List of usernames to try
            passwords: List of passwords to try
            timeout: Connection timeout
            
        Returns:
            Dictionary with brute force results
        """
        if usernames is None:
            usernames = ["anonymous", "admin", "user", "ftp", "root"]
        
        if passwords is None:
            passwords = ["", "anonymous@example.com", "password", "admin", "root", "123456", "password123"]
        
        result = {
            "target": target,
            "port": port,
            "success": False,
            "credentials": None,
            "attempts": 0
        }
        
        for username in usernames:
            for password in passwords:
                result["attempts"] += 1
                
                try:
                    ftp = ftplib.FTP(timeout=timeout)
                    ftp.connect(target, port)
                    ftp.login(username, password)
                    
                    # Login successful
                    result["success"] = True
                    result["credentials"] = {
                        "username": username,
                        "password": password
                    }
                    
                    # Save connection
                    self.ftp_client = ftp
                    self.current_connection = {
                        "target": target,
                        "port": port,
                        "is_anonymous": (username == "anonymous"),
                        "username": username,
                        "password": password
                    }
                    
                    logger.info(f"Found valid FTP credentials: {username}:{password}")
                    return result
                    
                except ftplib.error_perm:
                    # Authentication failed
                    continue
                except (socket.timeout, ConnectionRefusedError, OSError) as e:
                    # Connection issues
                    logger.warning(f"Connection error during brute force: {str(e)}")
                    result["error"] = str(e)
                    return result
        
        logger.info(f"FTP brute force completed, {result['attempts']} attempts, success: {result['success']}")
        return result
    
    def check_vulnerable_versions(self, version: str) -> List[Dict[str, Any]]:
        """
        Check if FTP version has known vulnerabilities
        
        Args:
            version: FTP server version
            
        Returns:
            List of known vulnerabilities
        """
        vulnerabilities = []
        
        # vsftpd vulnerable versions
        if version and version.startswith("2.3.4"):
            vulnerabilities.append({
                "cve": "CVE-2011-2523",
                "name": "vsftpd 2.3.4 Backdoor",
                "description": "vsftpd 2.3.4 contains a backdoor that executes a shell when a username contains a smiley face ':)'"
            })
        
        # ProFTPD vulnerabilities
        if version and version.startswith("1.3.5"):
            vulnerabilities.append({
                "cve": "CVE-2015-3306",
                "name": "ProFTPD 1.3.5 Mod_Copy Command Execution",
                "description": "ProFTPD 1.3.5 mod_copy module allows remote attackers to read and write to arbitrary files"
            })
        
        # Generic vulnerabilities for older versions
        if version and re.match(r'^[01]\.', version):
            vulnerabilities.append({
                "name": "Older FTP Version",
                "description": f"FTP server version {version} may be outdated and contain multiple vulnerabilities"
            })
        
        return vulnerabilities
    
    def close_connection(self) -> None:
        """Close current FTP connection"""
        if self.ftp_client:
            try:
                self.ftp_client.quit()
            except:
                self.ftp_client.close()
            finally:
                self.ftp_client = None
                self.current_connection = None

# Create singleton instance
ftp_scanner = FTPScanner()

def check_ftp_service(target: str, port: int = 21) -> Dict[str, Any]:
    """
    Check FTP service
    
    Args:
        target: Target hostname or IP
        port: FTP port
        
    Returns:
        Service status and details
    """
    return ftp_scanner.check_ftp_service(target, port)

def try_anonymous_login(target: str, port: int = 21) -> Dict[str, Any]:
    """
    Try anonymous FTP login
    
    Args:
        target: Target hostname or IP
        port: FTP port
        
    Returns:
        Login results
    """
    return ftp_scanner.try_anonymous_login(target, port)

def download_file(target: str, port: int, remote_path: str, local_path: str,
                username: str = "anonymous", password: str = "anonymous@example.com") -> bool:
    """
    Download file from FTP server
    
    Args:
        target: Target hostname or IP
        port: FTP port
        remote_path: Remote file path
        local_path: Local file path
        username: FTP username
        password: FTP password
        
    Returns:
        True if download successful
    """
    return ftp_scanner.download_file(target, port, remote_path, local_path, username, password)

def brute_force_login(target: str, port: int = 21, 
                     usernames: List[str] = None, passwords: List[str] = None) -> Dict[str, Any]:
    """
    Brute force FTP login
    
    Args:
        target: Target hostname or IP
        port: FTP port
        usernames: List of usernames to try
        passwords: List of passwords to try
        
    Returns:
        Brute force results
    """
    return ftp_scanner.brute_force_login(target, port, usernames, passwords)