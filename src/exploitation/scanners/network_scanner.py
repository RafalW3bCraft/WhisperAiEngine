"""
G3r4ki Network Scanner Module

This module provides network scanning capabilities similar to nmap,
allowing for service discovery and vulnerability identification.
"""

import subprocess
import re
import logging
import socket
import ipaddress
import json
from typing import Dict, List, Optional, Union, Any

# Setup logging
logger = logging.getLogger("g3r4ki.exploitation.scanners.network_scanner")

class NetworkScanException(Exception):
    """Exception for network scanning errors"""
    pass

class NetworkScanner:
    """
    Network Scanner class
    
    This class provides methods to scan networks and identify services
    similar to nmap functionality.
    """
    
    def __init__(self):
        """Initialize the network scanner"""
        self.last_scan_results = {}
        self.available_scan_types = {
            "quick": "Basic TCP port scan (-sT -T4)",
            "stealth": "SYN scan with minimal footprint (-sS -T2)",
            "comprehensive": "Full TCP scan with service detection and OS detection (-sT -sV -O -T4)",
            "vuln": "Vulnerability scan using NSE scripts (-sV --script vuln)",
            "all_ports": "Scan all 65535 ports (-p-)",
            "top_ports": "Scan top 1000 ports (default)",
            "udp": "Basic UDP scan (-sU -T4)",
            "default": "Standard balanced scan (-sV -T4)"
        }
    
    def _is_nmap_installed(self) -> bool:
        """
        Check if nmap is installed
        
        Returns:
            True if nmap is installed, False otherwise
        """
        try:
            subprocess.run(["which", "nmap"], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            return True
        except subprocess.CalledProcessError:
            return False
    
    def _validate_target(self, target: str) -> bool:
        """
        Validate target is a proper hostname, IP, or CIDR
        
        Args:
            target: Target to validate
            
        Returns:
            True if valid, False otherwise
        """
        # Check if it's a valid IP address
        try:
            ipaddress.ip_address(target)
            return True
        except ValueError:
            pass
        
        # Check if it's a valid CIDR
        try:
            ipaddress.ip_network(target, strict=False)
            return True
        except ValueError:
            pass
        
        # Check if it's a valid hostname
        try:
            socket.gethostbyname(target)
            return True
        except socket.gaierror:
            return False
    
    def _build_nmap_command(self, target: str, scan_type: str, ports: Optional[str] = None) -> List[str]:
        """
        Build the nmap command based on scan type
        
        Args:
            target: Target to scan
            scan_type: Type of scan to perform
            ports: Optional port specification
            
        Returns:
            List of command arguments
        """
        command = ["nmap"]
        
        if scan_type == "quick":
            command.extend(["-sT", "-T4"])
        elif scan_type == "stealth":
            command.extend(["-sS", "-T2"])
        elif scan_type == "comprehensive":
            command.extend(["-sT", "-sV", "-O", "-T4"])
        elif scan_type == "vuln":
            command.extend(["-sV", "--script", "vuln"])
        elif scan_type == "all_ports":
            command.extend(["-p-"])
        elif scan_type == "top_ports":
            command.extend(["-T4"])  # Default is top 1000 ports
        elif scan_type == "udp":
            command.extend(["-sU", "-T4"])
        else:  # default
            command.extend(["-sV", "-T4"])
        
        # Add specific ports if provided
        if ports:
            command.extend(["-p", ports])
        
        # Add JSON output format
        command.extend(["-oX", "-"])  # Output XML to stdout
        
        # Add target
        command.append(target)
        
        return command
    
    def _parse_nmap_xml(self, xml_output: str) -> Dict[str, Any]:
        """
        Parse nmap XML output
        
        Args:
            xml_output: Nmap XML output
            
        Returns:
            Dictionary of parsed results
        """
        import xml.etree.ElementTree as ET
        
        try:
            root = ET.fromstring(xml_output)
            
            # Extract scan information
            scan_info = {
                "scan_args": root.get("args", ""),
                "start_time": root.get("start", ""),
                "hosts": []
            }
            
            # Process each host
            for host in root.findall(".//host"):
                host_info = {
                    "status": host.find("status").get("state", "unknown") if host.find("status") is not None else "unknown",
                    "addresses": [],
                    "hostnames": [],
                    "ports": []
                }
                
                # Extract addresses
                for addr in host.findall("address"):
                    host_info["addresses"].append({
                        "addr": addr.get("addr", ""),
                        "type": addr.get("addrtype", "")
                    })
                
                # Extract hostnames
                for hostname in host.findall(".//hostname"):
                    host_info["hostnames"].append({
                        "name": hostname.get("name", ""),
                        "type": hostname.get("type", "")
                    })
                
                # Extract ports
                for port in host.findall(".//port"):
                    port_info = {
                        "port": port.get("portid", ""),
                        "protocol": port.get("protocol", ""),
                        "state": port.find("state").get("state", "") if port.find("state") is not None else "",
                        "service": {
                            "name": "",
                            "product": "",
                            "version": "",
                            "extrainfo": ""
                        }
                    }
                    
                    # Extract service info if available
                    service = port.find("service")
                    if service is not None:
                        port_info["service"] = {
                            "name": service.get("name", ""),
                            "product": service.get("product", ""),
                            "version": service.get("version", ""),
                            "extrainfo": service.get("extrainfo", "")
                        }
                    
                    host_info["ports"].append(port_info)
                
                # Extract OS information if available
                os_info = host.find(".//os")
                if os_info is not None:
                    os_matches = []
                    for os_match in os_info.findall(".//osmatch"):
                        os_matches.append({
                            "name": os_match.get("name", ""),
                            "accuracy": os_match.get("accuracy", "")
                        })
                    host_info["os_matches"] = os_matches
                
                scan_info["hosts"].append(host_info)
            
            return scan_info
            
        except ET.ParseError as e:
            logger.error(f"Error parsing nmap XML output: {str(e)}")
            return {"error": "Failed to parse nmap output"}
    
    def scan(self, target: str, scan_type: str = "default", ports: Optional[str] = None) -> Dict[str, Any]:
        """
        Scan a target using nmap
        
        Args:
            target: Target to scan (IP, hostname, or CIDR)
            scan_type: Type of scan to perform
            ports: Optional port specification (e.g., "22,80,443" or "1-1000")
            
        Returns:
            Dictionary containing scan results
            
        Raises:
            NetworkScanException: If scan fails
        """
        if not self._is_nmap_installed():
            raise NetworkScanException("nmap is not installed")
        
        if not self._validate_target(target):
            raise NetworkScanException(f"Invalid target: {target}")
        
        if scan_type not in self.available_scan_types:
            logger.warning(f"Invalid scan type: {scan_type}, using default")
            scan_type = "default"
        
        command = self._build_nmap_command(target, scan_type, ports)
        
        try:
            logger.info(f"Starting network scan on {target} with type {scan_type}")
            logger.debug(f"Running command: {' '.join(command)}")
            
            process = subprocess.run(
                command,
                check=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=False
            )
            
            xml_output = process.stdout.decode('utf-8', errors='ignore')
            results = self._parse_nmap_xml(xml_output)
            
            self.last_scan_results = results
            return results
            
        except subprocess.CalledProcessError as e:
            stderr = e.stderr.decode('utf-8', errors='ignore')
            logger.error(f"nmap scan failed: {stderr}")
            raise NetworkScanException(f"nmap scan failed: {stderr}")
    
    def get_available_scan_types(self) -> Dict[str, str]:
        """
        Get available scan types
        
        Returns:
            Dictionary mapping scan type IDs to descriptions
        """
        return self.available_scan_types
    
    def scan_multiple_targets(self, targets: List[str], scan_type: str = "default") -> Dict[str, Dict[str, Any]]:
        """
        Scan multiple targets
        
        Args:
            targets: List of targets to scan
            scan_type: Type of scan to perform
            
        Returns:
            Dictionary mapping targets to their scan results
        """
        results = {}
        for target in targets:
            try:
                results[target] = self.scan(target, scan_type)
            except NetworkScanException as e:
                results[target] = {"error": str(e)}
        
        return results
    
    def scan_network_range(self, cidr_range: str, scan_type: str = "quick") -> Dict[str, Any]:
        """
        Scan a network range
        
        Args:
            cidr_range: CIDR range to scan (e.g., "192.168.1.0/24")
            scan_type: Type of scan to perform
            
        Returns:
            Scan results
            
        Raises:
            NetworkScanException: If scan fails
        """
        try:
            ipaddress.ip_network(cidr_range, strict=False)
        except ValueError:
            raise NetworkScanException(f"Invalid CIDR range: {cidr_range}")
        
        return self.scan(cidr_range, scan_type)
    
    def format_results_table(self, results: Optional[Dict[str, Any]] = None) -> str:
        """
        Format scan results as a text table
        
        Args:
            results: Scan results dictionary
            
        Returns:
            Formatted table as string
        """
        if results is None:
            results = self.last_scan_results
        
        if not results or "hosts" not in results:
            return "No scan results available"
        
        output = []
        
        for host in results["hosts"]:
            ip_address = next((addr["addr"] for addr in host["addresses"] if addr["type"] == "ipv4"), "Unknown IP")
            hostname = next((h["name"] for h in host["hostnames"] if h["name"]), "")
            
            output.append(f"HOST: {ip_address} ({hostname})" if hostname else f"HOST: {ip_address}")
            output.append(f"STATUS: {host['status']}")
            output.append("")
            
            if "ports" in host and host["ports"]:
                output.append("PORT      STATE   SERVICE     VERSION")
                output.append("-" * 60)
                
                for port in host["ports"]:
                    port_num = port["port"]
                    protocol = port["protocol"]
                    state = port["state"]
                    service = port["service"]["name"]
                    product = port["service"]["product"]
                    version = port["service"]["version"]
                    
                    service_version = f"{product} {version}".strip()
                    
                    output.append(f"{port_num}/{protocol}  {state:6} {service:11} {service_version}")
                
                output.append("")
            
            if "os_matches" in host and host["os_matches"]:
                output.append("OS DETECTION:")
                for os_match in host["os_matches"]:
                    output.append(f"  {os_match['name']} (accuracy: {os_match['accuracy']}%)")
                output.append("")
            
            output.append("-" * 60)
        
        return "\n".join(output)

# Create singleton scanner instance
network_scanner = NetworkScanner()

def scan_target(target: str, scan_type: str = "default", ports: Optional[str] = None) -> Dict[str, Any]:
    """
    Scan a target
    
    Args:
        target: Target to scan
        scan_type: Type of scan to perform
        ports: Optional port specification
        
    Returns:
        Scan results
    """
    return network_scanner.scan(target, scan_type, ports)

def get_available_scan_types() -> Dict[str, str]:
    """
    Get available scan types
    
    Returns:
        Dictionary of available scan types
    """
    return network_scanner.get_available_scan_types()

def format_scan_results(results: Dict[str, Any]) -> str:
    """
    Format scan results
    
    Args:
        results: Scan results
        
    Returns:
        Formatted results
    """
    return network_scanner.format_results_table(results)