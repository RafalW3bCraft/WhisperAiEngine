"""
G3r4ki SMB Scanner Module

This module provides SMB service scanning and exploitation capabilities
for tasks like anonymous login, share enumeration, and file access.
"""

import subprocess
import socket
import logging
import os
import re
import tempfile
from typing import Dict, List, Optional, Union, Any, Tuple

# Setup logging
logger = logging.getLogger("g3r4ki.exploitation.scanners.smb_scanner")

class SMBScanException(Exception):
    """Exception for SMB scanning errors"""
    pass

class SMBScanner:
    """
    SMB Scanner class
    
    This class provides methods to scan and exploit SMB services.
    """
    
    def __init__(self):
        """Initialize the SMB scanner"""
        self.last_scan_results = {}
    
    def _is_tool_installed(self, tool: str) -> bool:
        """
        Check if a tool is installed
        
        Args:
            tool: Tool name
            
        Returns:
            True if installed, False otherwise
        """
        try:
            subprocess.run(["which", tool], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            return True
        except subprocess.CalledProcessError:
            return False
    
    def check_smb_service(self, target: str, timeout: int = 5) -> Dict[str, Any]:
        """
        Check if SMB service is running
        
        Args:
            target: Target hostname or IP
            timeout: Connection timeout in seconds
            
        Returns:
            Dictionary with service status
        """
        result = {
            "target": target,
            "status": "unknown",
            "ports": {
                "netbios": False,  # 139/tcp
                "smb": False,      # 445/tcp
            }
        }
        
        # Check NetBIOS port (139)
        try:
            with socket.create_connection((target, 139), timeout=timeout) as sock:
                result["ports"]["netbios"] = True
        except (socket.timeout, ConnectionRefusedError) as e:
            logger.debug(f"NetBIOS port closed on {target}: {str(e)}")
        
        # Check SMB port (445)
        try:
            with socket.create_connection((target, 445), timeout=timeout) as sock:
                result["ports"]["smb"] = True
        except (socket.timeout, ConnectionRefusedError) as e:
            logger.debug(f"SMB port closed on {target}: {str(e)}")
        
        # Set overall status
        if result["ports"]["netbios"] or result["ports"]["smb"]:
            result["status"] = "online"
        else:
            result["status"] = "offline"
        
        return result
    
    def enum_smb_shares(self, target: str, username: str = "", password: str = "") -> Dict[str, Any]:
        """
        Enumerate SMB shares using smbclient
        
        Args:
            target: Target hostname or IP
            username: SMB username (empty for null session)
            password: SMB password (empty for null session)
            
        Returns:
            Dictionary with enumeration results
            
        Raises:
            SMBScanException: If enumeration fails
        """
        if not self._is_tool_installed("smbclient"):
            raise SMBScanException("smbclient is not installed")
        
        result = {
            "target": target,
            "shares": [],
            "authentication": "null" if not username else "user"
        }
        
        # Build smbclient command
        command = ["smbclient", "-L", target, "-N"]
        if username:
            command.extend(["-U", username])
            if password:
                # Add password via environment variable to avoid showing in ps
                env = os.environ.copy()
                env["SMBPASSWD"] = password
                command.extend(["-P", "SMBPASSWD"])
        
        try:
            process = subprocess.run(
                command,
                check=False,  # Don't fail if return code is non-zero
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env if username and password else None,
                universal_newlines=True
            )
            
            if process.returncode != 0:
                error = process.stderr.strip()
                if "NT_STATUS_ACCESS_DENIED" in error:
                    result["error"] = "Access denied - authentication failed"
                elif "NT_STATUS_HOST_UNREACHABLE" in error:
                    result["error"] = "Host unreachable"
                else:
                    result["error"] = error
                
                logger.warning(f"SMB share enumeration failed: {result['error']}")
                return result
            
            # Parse the output
            shares = []
            disk_section = False
            
            for line in process.stdout.splitlines():
                line = line.strip()
                
                # Look for the disk shares section
                if "Disk" in line and "Sharename" in line:
                    disk_section = True
                    continue
                
                if disk_section and line:
                    # Skip section divider
                    if "---------" in line:
                        continue
                    
                    # End of disk section
                    if "IPC" in line and "IPC Service" in line:
                        disk_section = False
                        continue
                    
                    # Parse share line
                    parts = line.split(maxsplit=1)
                    if len(parts) >= 1:
                        share_name = parts[0].strip()
                        comment = parts[1].strip() if len(parts) > 1 else ""
                        
                        shares.append({
                            "name": share_name,
                            "comment": comment
                        })
            
            result["shares"] = shares
            result["success"] = True
            
            # Check accessibility for each share
            for share in result["shares"]:
                share_access = self.check_share_access(target, share["name"], username, password)
                share.update(share_access)
            
            return result
            
        except Exception as e:
            logger.error(f"Error enumerating SMB shares: {str(e)}")
            result["error"] = str(e)
            result["success"] = False
            return result
    
    def check_share_access(self, target: str, share_name: str, username: str = "", password: str = "") -> Dict[str, Any]:
        """
        Check if a share can be accessed
        
        Args:
            target: Target hostname or IP
            share_name: Share name
            username: SMB username (empty for null session)
            password: SMB password (empty for null session)
            
        Returns:
            Dictionary with access details
        """
        result = {
            "readable": False,
            "writeable": False
        }
        
        # Build command to list share contents
        command = ["smbclient", f"//{target}/{share_name}", "-c", "ls", "-N"]
        if username:
            command.extend(["-U", username])
            if password:
                # Add password via environment variable
                env = os.environ.copy()
                env["SMBPASSWD"] = password
                command.extend(["-P", "SMBPASSWD"])
        
        try:
            process = subprocess.run(
                command,
                check=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env if username and password else None,
                universal_newlines=True
            )
            
            # Check if we can read the share
            if process.returncode == 0 and "NT_STATUS" not in process.stderr:
                result["readable"] = True
                
                # If readable, check if writeable by trying to create a test directory
                test_dir = f".g3r4ki_test_{os.urandom(4).hex()}"
                
                mkdir_command = ["smbclient", f"//{target}/{share_name}", "-c", f"mkdir {test_dir}", "-N"]
                if username:
                    mkdir_command.extend(["-U", username])
                    if password:
                        mkdir_command.extend(["-P", "SMBPASSWD"])
                
                mkdir_process = subprocess.run(
                    mkdir_command,
                    check=False,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    env=env if username and password else None,
                    universal_newlines=True
                )
                
                # Check if directory creation succeeded
                if mkdir_process.returncode == 0 and "NT_STATUS" not in mkdir_process.stderr:
                    result["writeable"] = True
                    
                    # Clean up by removing the test directory
                    rmdir_command = ["smbclient", f"//{target}/{share_name}", "-c", f"rmdir {test_dir}", "-N"]
                    if username:
                        rmdir_command.extend(["-U", username])
                        if password:
                            rmdir_command.extend(["-P", "SMBPASSWD"])
                    
                    subprocess.run(
                        rmdir_command,
                        check=False,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        env=env if username and password else None
                    )
            
            return result
            
        except Exception as e:
            logger.error(f"Error checking share access: {str(e)}")
            return result
    
    def list_share_contents(self, target: str, share_name: str, path: str = "", 
                           username: str = "", password: str = "", recursive: bool = False) -> Dict[str, Any]:
        """
        List contents of SMB share
        
        Args:
            target: Target hostname or IP
            share_name: Share name
            path: Directory path within share
            username: SMB username (empty for null session)
            password: SMB password (empty for null session)
            recursive: Recursively list directory contents
            
        Returns:
            Dictionary with directory contents
            
        Raises:
            SMBScanException: If listing fails
        """
        if not self._is_tool_installed("smbclient"):
            raise SMBScanException("smbclient is not installed")
        
        result = {
            "target": target,
            "share": share_name,
            "path": path,
            "directories": [],
            "files": []
        }
        
        # Build command to list contents
        ls_command = "recurse;ls" if recursive else "ls"
        if path:
            ls_command = f"cd {path};{ls_command}"
            
        command = ["smbclient", f"//{target}/{share_name}", "-c", ls_command, "-N"]
        if username:
            command.extend(["-U", username])
            if password:
                # Add password via environment variable
                env = os.environ.copy()
                env["SMBPASSWD"] = password
                command.extend(["-P", "SMBPASSWD"])
        
        try:
            process = subprocess.run(
                command,
                check=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env if username and password else None,
                universal_newlines=True
            )
            
            if process.returncode != 0 or "NT_STATUS" in process.stderr:
                error = process.stderr.strip()
                raise SMBScanException(f"Failed to list share contents: {error}")
            
            # Parse the output
            current_dir = path if path else "/"
            dirs = []
            files = []
            
            for line in process.stdout.splitlines():
                line = line.strip()
                
                # Skip empty lines and directory headers
                if not line or "blocks available" in line or "blocks of size" in line:
                    continue
                
                # Check for directory change in recursive listing
                dir_match = re.match(r"^Directory of .*\\(.*)$", line)
                if dir_match:
                    current_dir = dir_match.group(1).replace("\\", "/")
                    continue
                
                # Parse directory listing line
                parts = line.split(maxsplit=3)
                if len(parts) < 4:
                    continue
                
                size_str = parts[2]
                name = parts[3]
                
                # Skip . and .. entries
                if name in [".", ".."]:
                    continue
                
                if parts[0].startswith("d"):
                    # Directory
                    dirs.append({
                        "name": name,
                        "path": f"{current_dir}/{name}".strip("/"),
                        "type": "directory"
                    })
                else:
                    # File
                    files.append({
                        "name": name,
                        "path": f"{current_dir}/{name}".strip("/"),
                        "size": size_str,
                        "type": "file"
                    })
            
            result["directories"] = dirs
            result["files"] = files
            result["success"] = True
            
            return result
            
        except SMBScanException as e:
            # Pass through our custom exceptions
            raise
        except Exception as e:
            logger.error(f"Error listing share contents: {str(e)}")
            raise SMBScanException(f"Error listing share contents: {str(e)}")
    
    def download_file(self, target: str, share_name: str, remote_path: str, local_path: str,
                     username: str = "", password: str = "") -> bool:
        """
        Download file from SMB share
        
        Args:
            target: Target hostname or IP
            share_name: Share name
            remote_path: Path to remote file
            local_path: Local destination path
            username: SMB username (empty for null session)
            password: SMB password (empty for null session)
            
        Returns:
            True if download successful
            
        Raises:
            SMBScanException: If download fails
        """
        if not self._is_tool_installed("smbclient"):
            raise SMBScanException("smbclient is not installed")
        
        # Create local directory if it doesn't exist
        local_dir = os.path.dirname(local_path)
        if local_dir and not os.path.exists(local_dir):
            os.makedirs(local_dir, exist_ok=True)
        
        # Build command to download file
        command = ["smbclient", f"//{target}/{share_name}", "-c", f"get \"{remote_path}\" \"{local_path}\"", "-N"]
        if username:
            command.extend(["-U", username])
            if password:
                # Add password via environment variable
                env = os.environ.copy()
                env["SMBPASSWD"] = password
                command.extend(["-P", "SMBPASSWD"])
        
        try:
            process = subprocess.run(
                command,
                check=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env if username and password else None,
                universal_newlines=True
            )
            
            if process.returncode != 0 or "NT_STATUS" in process.stderr:
                error = process.stderr.strip()
                raise SMBScanException(f"Failed to download file: {error}")
            
            if not os.path.exists(local_path):
                raise SMBScanException("File download failed: local file not created")
            
            logger.info(f"Successfully downloaded {remote_path} to {local_path}")
            return True
            
        except SMBScanException as e:
            # Pass through our custom exceptions
            raise
        except Exception as e:
            logger.error(f"Error downloading file: {str(e)}")
            raise SMBScanException(f"Error downloading file: {str(e)}")
    
    def upload_file(self, target: str, share_name: str, local_path: str, remote_path: str,
                   username: str = "", password: str = "") -> bool:
        """
        Upload file to SMB share
        
        Args:
            target: Target hostname or IP
            share_name: Share name
            local_path: Path to local file
            remote_path: Remote destination path
            username: SMB username (empty for null session)
            password: SMB password (empty for null session)
            
        Returns:
            True if upload successful
            
        Raises:
            SMBScanException: If upload fails
        """
        if not self._is_tool_installed("smbclient"):
            raise SMBScanException("smbclient is not installed")
        
        # Check if local file exists
        if not os.path.exists(local_path) or not os.path.isfile(local_path):
            raise SMBScanException(f"Local file {local_path} not found")
        
        # Build command to upload file
        command = ["smbclient", f"//{target}/{share_name}", "-c", f"put \"{local_path}\" \"{remote_path}\"", "-N"]
        if username:
            command.extend(["-U", username])
            if password:
                # Add password via environment variable
                env = os.environ.copy()
                env["SMBPASSWD"] = password
                command.extend(["-P", "SMBPASSWD"])
        
        try:
            process = subprocess.run(
                command,
                check=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                env=env if username and password else None,
                universal_newlines=True
            )
            
            if process.returncode != 0 or "NT_STATUS" in process.stderr:
                error = process.stderr.strip()
                raise SMBScanException(f"Failed to upload file: {error}")
            
            logger.info(f"Successfully uploaded {local_path} to {remote_path}")
            return True
            
        except SMBScanException as e:
            # Pass through our custom exceptions
            raise
        except Exception as e:
            logger.error(f"Error uploading file: {str(e)}")
            raise SMBScanException(f"Error uploading file: {str(e)}")
    
    def enum_users(self, target: str) -> Dict[str, Any]:
        """
        Enumerate SMB users using enum4linux
        
        Args:
            target: Target hostname or IP
            
        Returns:
            Dictionary with user enumeration results
            
        Raises:
            SMBScanException: If enumeration fails
        """
        if not self._is_tool_installed("enum4linux"):
            raise SMBScanException("enum4linux is not installed")
        
        result = {
            "target": target,
            "users": [],
            "groups": []
        }
        
        # Build enum4linux command
        command = ["enum4linux", "-u"]
        command.append(target)
        
        try:
            process = subprocess.run(
                command,
                check=False,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True
            )
            
            if process.returncode != 0:
                error = process.stderr.strip()
                raise SMBScanException(f"enum4linux failed: {error}")
            
            # Parse users from output
            users = []
            output = process.stdout
            
            # Look for users section
            user_section = False
            for line in output.splitlines():
                if "Users on" in line and target in line:
                    user_section = True
                    continue
                
                if user_section and "index:" in line and "RID:" in line:
                    # Parse user line
                    user_match = re.search(r"Account: (\S+)\s+Name: ([^\s]+)", line)
                    if user_match:
                        username = user_match.group(1)
                        name = user_match.group(2)
                        users.append({
                            "username": username,
                            "name": name
                        })
                
                # End of user section
                if user_section and "Groups on" in line:
                    user_section = False
            
            result["users"] = users
            
            # Parse groups from output
            groups = []
            group_section = False
            for line in output.splitlines():
                if "Groups on" in line and target in line:
                    group_section = True
                    continue
                
                if group_section and "index:" in line and "RID:" in line:
                    # Parse group line
                    group_match = re.search(r"Group: (\S+)\s+Name: ([^\s]+)", line)
                    if group_match:
                        group_name = group_match.group(1)
                        description = group_match.group(2)
                        groups.append({
                            "name": group_name,
                            "description": description
                        })
                
                # End of group section
                if group_section and "Users on" in line:
                    group_section = False
            
            result["groups"] = groups
            result["success"] = True
            
            return result
            
        except SMBScanException as e:
            # Pass through our custom exceptions
            raise
        except Exception as e:
            logger.error(f"Error enumerating SMB users: {str(e)}")
            raise SMBScanException(f"Error enumerating SMB users: {str(e)}")
    
    def brute_force_login(self, target: str, usernames: List[str], passwords: List[str]) -> Dict[str, Any]:
        """
        Brute force SMB login
        
        Args:
            target: Target hostname or IP
            usernames: List of usernames to try
            passwords: List of passwords to try
            
        Returns:
            Dictionary with brute force results
            
        Raises:
            SMBScanException: If brute force fails
        """
        if not self._is_tool_installed("smbclient"):
            raise SMBScanException("smbclient is not installed")
        
        result = {
            "target": target,
            "valid_credentials": [],
            "attempts": 0
        }
        
        for username in usernames:
            for password in passwords:
                result["attempts"] += 1
                
                # Build command to test login
                command = ["smbclient", "-L", target, "-U", username, "-P", "SMBPASSWD"]
                
                try:
                    env = os.environ.copy()
                    env["SMBPASSWD"] = password
                    
                    process = subprocess.run(
                        command,
                        check=False,
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        env=env,
                        universal_newlines=True
                    )
                    
                    # Check if login succeeded
                    if process.returncode == 0 and "NT_STATUS_ACCESS_DENIED" not in process.stderr:
                        result["valid_credentials"].append({
                            "username": username,
                            "password": password
                        })
                        logger.info(f"Found valid SMB credentials: {username}:{password}")
                    
                except Exception as e:
                    logger.warning(f"Error during SMB brute force attempt: {str(e)}")
        
        result["success"] = True
        logger.info(f"SMB brute force completed: {len(result['valid_credentials'])} valid credentials found")
        return result

# Create singleton instance
smb_scanner = SMBScanner()

def check_smb_service(target: str) -> Dict[str, Any]:
    """
    Check if SMB service is running
    
    Args:
        target: Target hostname or IP
        
    Returns:
        Service status
    """
    return smb_scanner.check_smb_service(target)

def enum_smb_shares(target: str, username: str = "", password: str = "") -> Dict[str, Any]:
    """
    Enumerate SMB shares
    
    Args:
        target: Target hostname or IP
        username: SMB username (empty for null session)
        password: SMB password (empty for null session)
        
    Returns:
        Enumeration results
    """
    return smb_scanner.enum_smb_shares(target, username, password)

def list_share_contents(target: str, share_name: str, path: str = "", 
                       username: str = "", password: str = "") -> Dict[str, Any]:
    """
    List contents of SMB share
    
    Args:
        target: Target hostname or IP
        share_name: Share name
        path: Directory path within share
        username: SMB username (empty for null session)
        password: SMB password (empty for null session)
        
    Returns:
        Directory contents
    """
    return smb_scanner.list_share_contents(target, share_name, path, username, password)

def download_file(target: str, share_name: str, remote_path: str, local_path: str,
                 username: str = "", password: str = "") -> bool:
    """
    Download file from SMB share
    
    Args:
        target: Target hostname or IP
        share_name: Share name
        remote_path: Path to remote file
        local_path: Local destination path
        username: SMB username (empty for null session)
        password: SMB password (empty for null session)
        
    Returns:
        True if download successful
    """
    return smb_scanner.download_file(target, share_name, remote_path, local_path, username, password)

def enum_users(target: str) -> Dict[str, Any]:
    """
    Enumerate SMB users
    
    Args:
        target: Target hostname or IP
        
    Returns:
        User enumeration results
    """
    return smb_scanner.enum_users(target)