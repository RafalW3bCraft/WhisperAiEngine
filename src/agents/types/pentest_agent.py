"""
G3r4ki Penetration Testing Agent

This module provides an agent for penetration testing operations.
"""

import logging
import socket
import time
from typing import Dict, List, Optional, Any, Tuple, Union
import ipaddress

from src.agents.core.base import Agent, AgentStatus
from src.pentest.shells import list_shell_types, list_variants, generate_shell, get_local_ip

# Setup logging
logger = logging.getLogger("g3r4ki.agents.pentest")

class PentestAgent(Agent):
    """
    Penetration Testing Agent
    
    This agent specializes in penetration testing operations.
    """
    
    def __init__(self, name: str, description: Optional[str] = None):
        """
        Initialize a penetration testing agent
        
        Args:
            name: Agent name
            description: Optional description
        """
        super().__init__(name, description or "Penetration Testing Agent")
        
        # Penetration testing specific attributes
        self.scan_results = {}
        self.vulnerabilities = []
        self.exploits = []
        self.shells = []
        
        logger.info(f"PentestAgent initialized: {name}")
    
    def run(self) -> Dict[str, Any]:
        """
        Run the penetration testing workflow
        
        Returns:
            Results dictionary
        """
        self.status = AgentStatus.EXECUTING
        self.last_active = time.time()
        
        try:
            logger.info(f"Running PentestAgent: {self.name}")
            
            if not self.target:
                raise ValueError("Target not set")
            
            # Create a plan
            self.status = AgentStatus.PLANNING
            plan = self.plan()
            
            # Execute the plan
            self.status = AgentStatus.EXECUTING
            self.results = self.execute_plan(plan)
            
        except Exception as e:
            logger.error(f"Error running PentestAgent {self.name}: {str(e)}")
            self.status = AgentStatus.ERROR
            self.results = {"error": str(e)}
        
        self.status = AgentStatus.COMPLETED
        return self.results
    
    def plan(self) -> List[Dict[str, Any]]:
        """
        Create a penetration testing plan
        
        Returns:
            List of steps to execute
        """
        # Basic plan, can be enhanced with more sophisticated planning
        plan = [
            {"step": "recon", "description": "Initial reconnaissance"},
            {"step": "scan", "description": "Network scanning"},
            {"step": "enumerate", "description": "Service enumeration"},
            {"step": "analyze", "description": "Vulnerability analysis"},
            {"step": "exploit", "description": "Exploitation (if authorized)"},
            {"step": "report", "description": "Generate report"}
        ]
        
        logger.info(f"PentestAgent {self.name} created plan with {len(plan)} steps")
        return plan
    
    def execute_plan(self, plan: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Execute the penetration testing plan
        
        Args:
            plan: Plan to execute
            
        Returns:
            Results from execution
        """
        results = {
            "plan": plan,
            "steps_executed": [],
            "findings": {},
            "summary": ""
        }
        
        for step in plan:
            step_name = step["step"]
            logger.info(f"Executing step: {step_name}")
            
            step_result = self._execute_step(step_name)
            results["steps_executed"].append({
                "step": step_name,
                "result": step_result
            })
            
            # Add specific findings to the overall results
            if step_result.get("findings"):
                results["findings"][step_name] = step_result["findings"]
        
        # Generate a summary
        results["summary"] = self._generate_summary(results)
        
        return results
    
    def _execute_step(self, step_name: str) -> Dict[str, Any]:
        """
        Execute a specific step of the penetration testing plan
        
        Args:
            step_name: Name of the step to execute
            
        Returns:
            Results from the step execution
        """
        # Simplified step execution - in a real implementation,
        # these would use actual scanning and analysis tools
        if step_name == "recon":
            return self._perform_recon()
        elif step_name == "scan":
            return self._perform_scan()
        elif step_name == "enumerate":
            return self._perform_enumeration()
        elif step_name == "analyze":
            return self._perform_analysis()
        elif step_name == "exploit":
            return self._perform_exploitation()
        elif step_name == "report":
            return {"status": "completed"}
        else:
            return {"status": "unknown_step"}
    
    def _perform_recon(self) -> Dict[str, Any]:
        """
        Perform reconnaissance
        
        Returns:
            Reconnaissance results
        """
        results = {
            "status": "completed",
            "findings": {
                "target_info": {
                    "target": self.target,
                    "is_ip": self._is_ip_address(self.target),
                    "timestamp": time.time()
                }
            }
        }
        
        # Attempt reverse DNS lookup for IP addresses
        if results["findings"]["target_info"]["is_ip"]:
            try:
                hostname, _, _ = socket.gethostbyaddr(self.target)
                results["findings"]["target_info"]["hostname"] = hostname
            except (socket.herror, socket.gaierror):
                results["findings"]["target_info"]["hostname"] = None
        
        return results
    
    def _perform_scan(self) -> Dict[str, Any]:
        """
        Perform network scanning
        
        Returns:
            Scanning results
        """
        # Simplified scan simulation
        return {
            "status": "completed",
            "findings": {
                "open_ports": [22, 80, 443],  # Simulated open ports
                "timestamp": time.time()
            }
        }
    
    def _perform_enumeration(self) -> Dict[str, Any]:
        """
        Perform service enumeration
        
        Returns:
            Enumeration results
        """
        # Simplified enumeration simulation
        return {
            "status": "completed",
            "findings": {
                "services": {
                    "22": "SSH",
                    "80": "HTTP",
                    "443": "HTTPS"
                },
                "timestamp": time.time()
            }
        }
    
    def _perform_analysis(self) -> Dict[str, Any]:
        """
        Perform vulnerability analysis
        
        Returns:
            Analysis results
        """
        # Simplified vulnerability analysis simulation
        return {
            "status": "completed",
            "findings": {
                "vulnerabilities": [
                    {
                        "id": "CVE-2023-12345",
                        "severity": "medium",
                        "description": "Example vulnerability"
                    }
                ],
                "timestamp": time.time()
            }
        }
    
    def _perform_exploitation(self) -> Dict[str, Any]:
        """
        Perform exploitation (if authorized)
        
        Returns:
            Exploitation results
        """
        # In a real implementation, this would only proceed with explicit authorization
        # For simulation, just return a not authorized message
        return {
            "status": "skipped",
            "reason": "Exploitation requires explicit authorization"
        }
    
    def _generate_summary(self, results: Dict[str, Any]) -> str:
        """
        Generate a summary of the penetration test
        
        Args:
            results: Test results
            
        Returns:
            Summary text
        """
        findings = results.get("findings", {})
        steps_executed = len(results.get("steps_executed", []))
        
        # Count vulnerabilities
        vuln_count = 0
        if "analyze" in findings:
            vuln_count = len(findings["analyze"].get("vulnerabilities", []))
        
        summary = (
            f"Penetration test completed for target {self.target}. "
            f"Executed {steps_executed} steps. "
            f"Found {vuln_count} potential vulnerabilities."
        )
        
        return summary
    
    def _is_ip_address(self, target: str) -> bool:
        """
        Check if the target is an IP address
        
        Args:
            target: Target string
            
        Returns:
            True if target is an IP address, False otherwise
        """
        try:
            ipaddress.ip_address(target)
            return True
        except ValueError:
            return False
    
    def generate_shell_examples(self, ip: Optional[str] = None, port: int = 4444) -> Dict[str, str]:
        """
        Generate example reverse shells for the target
        
        Args:
            ip: IP address to connect back to (default: auto-detect)
            port: Port to connect back to
            
        Returns:
            Dictionary of shell examples
        """
        if not ip:
            ip = get_local_ip()
        
        shells = {}
        
        # Generate a few common shell examples
        shells["bash"] = generate_shell("bash", "basic", ip, port)
        shells["python"] = generate_shell("python", "basic", ip, port)
        shells["php"] = generate_shell("php", "basic", ip, port)
        shells["powershell"] = generate_shell("powershell", "basic", ip, port)
        
        return shells